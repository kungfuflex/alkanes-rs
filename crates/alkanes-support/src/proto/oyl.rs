// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 28.2
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `oyl.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:oyl.TokenId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenId {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenId.block)
    pub block: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenId.tx)
    pub tx: ::protobuf::MessageField<super::alkanes::Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenId {
    fn default() -> &'a TokenId {
        <TokenId as ::protobuf::Message>::default_instance()
    }
}

impl TokenId {
    pub fn new() -> TokenId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "block",
            |m: &TokenId| { &m.block },
            |m: &mut TokenId| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "tx",
            |m: &TokenId| { &m.tx },
            |m: &mut TokenId| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenId>(
            "TokenId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenId {
    const NAME: &'static str = "TokenId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tx.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenId {
        TokenId::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenId {
        static instance: TokenId = TokenId {
            block: ::protobuf::MessageField::none(),
            tx: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolId)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolId {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolId.block)
    pub block: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.PoolId.tx)
    pub tx: ::protobuf::MessageField<super::alkanes::Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolId.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolId {
    fn default() -> &'a PoolId {
        <PoolId as ::protobuf::Message>::default_instance()
    }
}

impl PoolId {
    pub fn new() -> PoolId {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "block",
            |m: &PoolId| { &m.block },
            |m: &mut PoolId| { &mut m.block },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "tx",
            |m: &PoolId| { &m.tx },
            |m: &mut PoolId| { &mut m.tx },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolId>(
            "PoolId",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolId {
    const NAME: &'static str = "PoolId";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.block)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tx)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.block.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tx.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolId {
        PoolId::new()
    }

    fn clear(&mut self) {
        self.block.clear();
        self.tx.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolId {
        static instance: PoolId = PoolId {
            block: ::protobuf::MessageField::none(),
            tx: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolId {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolId").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolId {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolId {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.Timestamp)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Timestamp {
    // message fields
    // @@protoc_insertion_point(field:oyl.Timestamp.seconds)
    pub seconds: u64,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.Timestamp.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Timestamp {
    fn default() -> &'a Timestamp {
        <Timestamp as ::protobuf::Message>::default_instance()
    }
}

impl Timestamp {
    pub fn new() -> Timestamp {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seconds",
            |m: &Timestamp| { &m.seconds },
            |m: &mut Timestamp| { &mut m.seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Timestamp>(
            "Timestamp",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Timestamp {
    const NAME: &'static str = "Timestamp";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.seconds = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.seconds != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.seconds);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.seconds != 0 {
            os.write_uint64(1, self.seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Timestamp {
        Timestamp::new()
    }

    fn clear(&mut self) {
        self.seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Timestamp {
        static instance: Timestamp = Timestamp {
            seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Timestamp {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Timestamp").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Timestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timestamp {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.Price)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Price {
    // message fields
    // @@protoc_insertion_point(field:oyl.Price.value)
    pub value: f64,
    // @@protoc_insertion_point(field:oyl.Price.currency)
    pub currency: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.Price.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Price {
    fn default() -> &'a Price {
        <Price as ::protobuf::Message>::default_instance()
    }
}

impl Price {
    pub fn new() -> Price {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Price| { &m.value },
            |m: &mut Price| { &mut m.value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &Price| { &m.currency },
            |m: &mut Price| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Price>(
            "Price",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Price {
    const NAME: &'static str = "Price";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                18 => {
                    self.currency = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.currency);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        if !self.currency.is_empty() {
            os.write_string(2, &self.currency)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Price {
        Price::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.currency.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Price {
        static instance: Price = Price {
            value: 0.,
            currency: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Price {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Price").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Price {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Price {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.Volume)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Volume {
    // message fields
    // @@protoc_insertion_point(field:oyl.Volume.amount)
    pub amount: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.Volume.value_usd)
    pub value_usd: ::protobuf::MessageField<Price>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.Volume.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Volume {
    fn default() -> &'a Volume {
        <Volume as ::protobuf::Message>::default_instance()
    }
}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "amount",
            |m: &Volume| { &m.amount },
            |m: &mut Volume| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "value_usd",
            |m: &Volume| { &m.value_usd },
            |m: &mut Volume| { &mut m.value_usd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Volume>(
            "Volume",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Volume {
    const NAME: &'static str = "Volume";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value_usd)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value_usd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.value_usd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Volume {
        Volume::new()
    }

    fn clear(&mut self) {
        self.amount.clear();
        self.value_usd.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Volume {
        static instance: Volume = Volume {
            amount: ::protobuf::MessageField::none(),
            value_usd: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Volume {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Volume").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.Percentage)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Percentage {
    // message fields
    // @@protoc_insertion_point(field:oyl.Percentage.value)
    pub value: f64,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.Percentage.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Percentage {
    fn default() -> &'a Percentage {
        <Percentage as ::protobuf::Message>::default_instance()
    }
}

impl Percentage {
    pub fn new() -> Percentage {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &Percentage| { &m.value },
            |m: &mut Percentage| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Percentage>(
            "Percentage",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Percentage {
    const NAME: &'static str = "Percentage";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                9 => {
                    self.value = is.read_double()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.value != 0. {
            my_size += 1 + 8;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.value != 0. {
            os.write_double(1, self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Percentage {
        Percentage::new()
    }

    fn clear(&mut self) {
        self.value = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Percentage {
        static instance: Percentage = Percentage {
            value: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Percentage {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Percentage").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Percentage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Percentage {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenInfo {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenInfo.id)
    pub id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.symbol)
    pub symbol: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.TokenInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.TokenInfo.logo_url)
    pub logo_url: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.TokenInfo.logo_data)
    pub logo_data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.total_supply)
    pub total_supply: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.circulating_supply)
    pub circulating_supply: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.max_supply)
    pub max_supply: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.created_at)
    pub created_at: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.block_created)
    pub block_created: u32,
    // @@protoc_insertion_point(field:oyl.TokenInfo.mint_progress)
    pub mint_progress: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenInfo.explorer_links)
    pub explorer_links: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenInfo {
    fn default() -> &'a TokenInfo {
        <TokenInfo as ::protobuf::Message>::default_instance()
    }
}

impl TokenInfo {
    pub fn new() -> TokenInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "id",
            |m: &TokenInfo| { &m.id },
            |m: &mut TokenInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "symbol",
            |m: &TokenInfo| { &m.symbol },
            |m: &mut TokenInfo| { &mut m.symbol },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &TokenInfo| { &m.name },
            |m: &mut TokenInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logo_url",
            |m: &TokenInfo| { &m.logo_url },
            |m: &mut TokenInfo| { &mut m.logo_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "logo_data",
            |m: &TokenInfo| { &m.logo_data },
            |m: &mut TokenInfo| { &mut m.logo_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "total_supply",
            |m: &TokenInfo| { &m.total_supply },
            |m: &mut TokenInfo| { &mut m.total_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "circulating_supply",
            |m: &TokenInfo| { &m.circulating_supply },
            |m: &mut TokenInfo| { &mut m.circulating_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "max_supply",
            |m: &TokenInfo| { &m.max_supply },
            |m: &mut TokenInfo| { &mut m.max_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "created_at",
            |m: &TokenInfo| { &m.created_at },
            |m: &mut TokenInfo| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_created",
            |m: &TokenInfo| { &m.block_created },
            |m: &mut TokenInfo| { &mut m.block_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "mint_progress",
            |m: &TokenInfo| { &m.mint_progress },
            |m: &mut TokenInfo| { &mut m.mint_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "explorer_links",
            |m: &TokenInfo| { &m.explorer_links },
            |m: &mut TokenInfo| { &mut m.explorer_links },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenInfo>(
            "TokenInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenInfo {
    const NAME: &'static str = "TokenInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    self.symbol = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.logo_url = is.read_string()?;
                },
                42 => {
                    self.logo_data = is.read_bytes()?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_supply)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.circulating_supply)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.max_supply)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                80 => {
                    self.block_created = is.read_uint32()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.mint_progress)?;
                },
                98 => {
                    self.explorer_links.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.symbol.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.symbol);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.logo_url.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.logo_url);
        }
        if !self.logo_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.logo_data);
        }
        if let Some(v) = self.total_supply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.circulating_supply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.max_supply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_created != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.block_created);
        }
        if let Some(v) = self.mint_progress.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.explorer_links {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.symbol.is_empty() {
            os.write_string(2, &self.symbol)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.logo_url.is_empty() {
            os.write_string(4, &self.logo_url)?;
        }
        if !self.logo_data.is_empty() {
            os.write_bytes(5, &self.logo_data)?;
        }
        if let Some(v) = self.total_supply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.circulating_supply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.max_supply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if self.block_created != 0 {
            os.write_uint32(10, self.block_created)?;
        }
        if let Some(v) = self.mint_progress.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        for v in &self.explorer_links {
            os.write_string(12, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenInfo {
        TokenInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.symbol.clear();
        self.name.clear();
        self.logo_url.clear();
        self.logo_data.clear();
        self.total_supply.clear();
        self.circulating_supply.clear();
        self.max_supply.clear();
        self.created_at.clear();
        self.block_created = 0;
        self.mint_progress.clear();
        self.explorer_links.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenInfo {
        static instance: TokenInfo = TokenInfo {
            id: ::protobuf::MessageField::none(),
            symbol: ::std::string::String::new(),
            name: ::std::string::String::new(),
            logo_url: ::std::string::String::new(),
            logo_data: ::std::vec::Vec::new(),
            total_supply: ::protobuf::MessageField::none(),
            circulating_supply: ::protobuf::MessageField::none(),
            max_supply: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            block_created: 0,
            mint_progress: ::protobuf::MessageField::none(),
            explorer_links: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenPrice)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenPrice {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenPrice.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.current_price)
    pub current_price: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.price_change_1h)
    pub price_change_1h: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.price_change_24h)
    pub price_change_24h: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.price_change_7d)
    pub price_change_7d: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.price_change_30d)
    pub price_change_30d: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.price_change_all)
    pub price_change_all: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenPrice.last_updated)
    pub last_updated: ::protobuf::MessageField<Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenPrice.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenPrice {
    fn default() -> &'a TokenPrice {
        <TokenPrice as ::protobuf::Message>::default_instance()
    }
}

impl TokenPrice {
    pub fn new() -> TokenPrice {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenPrice| { &m.token_id },
            |m: &mut TokenPrice| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "current_price",
            |m: &TokenPrice| { &m.current_price },
            |m: &mut TokenPrice| { &mut m.current_price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "price_change_1h",
            |m: &TokenPrice| { &m.price_change_1h },
            |m: &mut TokenPrice| { &mut m.price_change_1h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "price_change_24h",
            |m: &TokenPrice| { &m.price_change_24h },
            |m: &mut TokenPrice| { &mut m.price_change_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "price_change_7d",
            |m: &TokenPrice| { &m.price_change_7d },
            |m: &mut TokenPrice| { &mut m.price_change_7d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "price_change_30d",
            |m: &TokenPrice| { &m.price_change_30d },
            |m: &mut TokenPrice| { &mut m.price_change_30d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "price_change_all",
            |m: &TokenPrice| { &m.price_change_all },
            |m: &mut TokenPrice| { &mut m.price_change_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "last_updated",
            |m: &TokenPrice| { &m.last_updated },
            |m: &mut TokenPrice| { &mut m.last_updated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenPrice>(
            "TokenPrice",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenPrice {
    const NAME: &'static str = "TokenPrice";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current_price)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_change_1h)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_change_24h)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_change_7d)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_change_30d)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_change_all)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_updated)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.current_price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price_change_1h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price_change_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price_change_7d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price_change_30d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price_change_all.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.current_price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.price_change_1h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.price_change_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.price_change_7d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.price_change_30d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.price_change_all.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.last_updated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenPrice {
        TokenPrice::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.current_price.clear();
        self.price_change_1h.clear();
        self.price_change_24h.clear();
        self.price_change_7d.clear();
        self.price_change_30d.clear();
        self.price_change_all.clear();
        self.last_updated.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenPrice {
        static instance: TokenPrice = TokenPrice {
            token_id: ::protobuf::MessageField::none(),
            current_price: ::protobuf::MessageField::none(),
            price_change_1h: ::protobuf::MessageField::none(),
            price_change_24h: ::protobuf::MessageField::none(),
            price_change_7d: ::protobuf::MessageField::none(),
            price_change_30d: ::protobuf::MessageField::none(),
            price_change_all: ::protobuf::MessageField::none(),
            last_updated: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenPrice {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenPrice").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenPrice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenPrice {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenHolder)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenHolder {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenHolder.address)
    pub address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.TokenHolder.balance)
    pub balance: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenHolder.percent_of_supply)
    pub percent_of_supply: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.TokenHolder.first_acquired)
    pub first_acquired: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenHolder.last_activity)
    pub last_activity: ::protobuf::MessageField<Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenHolder.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenHolder {
    fn default() -> &'a TokenHolder {
        <TokenHolder as ::protobuf::Message>::default_instance()
    }
}

impl TokenHolder {
    pub fn new() -> TokenHolder {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &TokenHolder| { &m.address },
            |m: &mut TokenHolder| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "balance",
            |m: &TokenHolder| { &m.balance },
            |m: &mut TokenHolder| { &mut m.balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "percent_of_supply",
            |m: &TokenHolder| { &m.percent_of_supply },
            |m: &mut TokenHolder| { &mut m.percent_of_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "first_acquired",
            |m: &TokenHolder| { &m.first_acquired },
            |m: &mut TokenHolder| { &mut m.first_acquired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "last_activity",
            |m: &TokenHolder| { &m.last_activity },
            |m: &mut TokenHolder| { &mut m.last_activity },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenHolder>(
            "TokenHolder",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenHolder {
    const NAME: &'static str = "TokenHolder";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.balance)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.percent_of_supply)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.first_acquired)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_activity)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.address);
        }
        if let Some(v) = self.balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.percent_of_supply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.first_acquired.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.last_activity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.address.is_empty() {
            os.write_bytes(1, &self.address)?;
        }
        if let Some(v) = self.balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.percent_of_supply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.first_acquired.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.last_activity.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenHolder {
        TokenHolder::new()
    }

    fn clear(&mut self) {
        self.address.clear();
        self.balance.clear();
        self.percent_of_supply.clear();
        self.first_acquired.clear();
        self.last_activity.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenHolder {
        static instance: TokenHolder = TokenHolder {
            address: ::std::vec::Vec::new(),
            balance: ::protobuf::MessageField::none(),
            percent_of_supply: ::protobuf::MessageField::none(),
            first_acquired: ::protobuf::MessageField::none(),
            last_activity: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenHolder {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenHolder").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenHolder {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenHolder {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenMetrics {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenMetrics.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.total_holders)
    pub total_holders: u64,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.volume_1h)
    pub volume_1h: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.volume_24h)
    pub volume_24h: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.volume_7d)
    pub volume_7d: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.volume_30d)
    pub volume_30d: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.volume_all)
    pub volume_all: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.market_cap)
    pub market_cap: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.fdv)
    pub fdv: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.tvl)
    pub tvl: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.TokenMetrics.pool_count)
    pub pool_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenMetrics {
    fn default() -> &'a TokenMetrics {
        <TokenMetrics as ::protobuf::Message>::default_instance()
    }
}

impl TokenMetrics {
    pub fn new() -> TokenMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenMetrics| { &m.token_id },
            |m: &mut TokenMetrics| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_holders",
            |m: &TokenMetrics| { &m.total_holders },
            |m: &mut TokenMetrics| { &mut m.total_holders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_1h",
            |m: &TokenMetrics| { &m.volume_1h },
            |m: &mut TokenMetrics| { &mut m.volume_1h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_24h",
            |m: &TokenMetrics| { &m.volume_24h },
            |m: &mut TokenMetrics| { &mut m.volume_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_7d",
            |m: &TokenMetrics| { &m.volume_7d },
            |m: &mut TokenMetrics| { &mut m.volume_7d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_30d",
            |m: &TokenMetrics| { &m.volume_30d },
            |m: &mut TokenMetrics| { &mut m.volume_30d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_all",
            |m: &TokenMetrics| { &m.volume_all },
            |m: &mut TokenMetrics| { &mut m.volume_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "market_cap",
            |m: &TokenMetrics| { &m.market_cap },
            |m: &mut TokenMetrics| { &mut m.market_cap },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fdv",
            |m: &TokenMetrics| { &m.fdv },
            |m: &mut TokenMetrics| { &mut m.fdv },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "tvl",
            |m: &TokenMetrics| { &m.tvl },
            |m: &mut TokenMetrics| { &mut m.tvl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pool_count",
            |m: &TokenMetrics| { &m.pool_count },
            |m: &mut TokenMetrics| { &mut m.pool_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenMetrics>(
            "TokenMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenMetrics {
    const NAME: &'static str = "TokenMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                16 => {
                    self.total_holders = is.read_uint64()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_1h)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_24h)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_7d)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_30d)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_all)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.market_cap)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fdv)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl)?;
                },
                88 => {
                    self.pool_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total_holders != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.total_holders);
        }
        if let Some(v) = self.volume_1h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_7d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_30d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_all.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.market_cap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fdv.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.pool_count != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.pool_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.total_holders != 0 {
            os.write_uint64(2, self.total_holders)?;
        }
        if let Some(v) = self.volume_1h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.volume_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.volume_7d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.volume_30d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.volume_all.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.market_cap.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.fdv.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.tvl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if self.pool_count != 0 {
            os.write_uint32(11, self.pool_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenMetrics {
        TokenMetrics::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.total_holders = 0;
        self.volume_1h.clear();
        self.volume_24h.clear();
        self.volume_7d.clear();
        self.volume_30d.clear();
        self.volume_all.clear();
        self.market_cap.clear();
        self.fdv.clear();
        self.tvl.clear();
        self.pool_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenMetrics {
        static instance: TokenMetrics = TokenMetrics {
            token_id: ::protobuf::MessageField::none(),
            total_holders: 0,
            volume_1h: ::protobuf::MessageField::none(),
            volume_24h: ::protobuf::MessageField::none(),
            volume_7d: ::protobuf::MessageField::none(),
            volume_30d: ::protobuf::MessageField::none(),
            volume_all: ::protobuf::MessageField::none(),
            market_cap: ::protobuf::MessageField::none(),
            fdv: ::protobuf::MessageField::none(),
            tvl: ::protobuf::MessageField::none(),
            pool_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolInfo {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolInfo.id)
    pub id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.token_a)
    pub token_a: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.token_b)
    pub token_b: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.PoolInfo.reserve_a)
    pub reserve_a: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.reserve_b)
    pub reserve_b: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.total_supply)
    pub total_supply: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.created_at)
    pub created_at: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolInfo.block_created)
    pub block_created: u32,
    // @@protoc_insertion_point(field:oyl.PoolInfo.explorer_link)
    pub explorer_link: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.PoolInfo.factory_id)
    pub factory_id: ::protobuf::MessageField<TokenId>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolInfo {
    fn default() -> &'a PoolInfo {
        <PoolInfo as ::protobuf::Message>::default_instance()
    }
}

impl PoolInfo {
    pub fn new() -> PoolInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "id",
            |m: &PoolInfo| { &m.id },
            |m: &mut PoolInfo| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_a",
            |m: &PoolInfo| { &m.token_a },
            |m: &mut PoolInfo| { &mut m.token_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_b",
            |m: &PoolInfo| { &m.token_b },
            |m: &mut PoolInfo| { &mut m.token_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &PoolInfo| { &m.name },
            |m: &mut PoolInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "reserve_a",
            |m: &PoolInfo| { &m.reserve_a },
            |m: &mut PoolInfo| { &mut m.reserve_a },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "reserve_b",
            |m: &PoolInfo| { &m.reserve_b },
            |m: &mut PoolInfo| { &mut m.reserve_b },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "total_supply",
            |m: &PoolInfo| { &m.total_supply },
            |m: &mut PoolInfo| { &mut m.total_supply },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "created_at",
            |m: &PoolInfo| { &m.created_at },
            |m: &mut PoolInfo| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_created",
            |m: &PoolInfo| { &m.block_created },
            |m: &mut PoolInfo| { &mut m.block_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "explorer_link",
            |m: &PoolInfo| { &m.explorer_link },
            |m: &mut PoolInfo| { &mut m.explorer_link },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "factory_id",
            |m: &PoolInfo| { &m.factory_id },
            |m: &mut PoolInfo| { &mut m.factory_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolInfo>(
            "PoolInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolInfo {
    const NAME: &'static str = "PoolInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_a)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_b)?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reserve_a)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.reserve_b)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_supply)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                72 => {
                    self.block_created = is.read_uint32()?;
                },
                82 => {
                    self.explorer_link = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.factory_id)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.token_a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.token_b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        if let Some(v) = self.reserve_a.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.reserve_b.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_supply.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_created != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.block_created);
        }
        if !self.explorer_link.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.explorer_link);
        }
        if let Some(v) = self.factory_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.token_a.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.token_b.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        if let Some(v) = self.reserve_a.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.reserve_b.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.total_supply.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.block_created != 0 {
            os.write_uint32(9, self.block_created)?;
        }
        if !self.explorer_link.is_empty() {
            os.write_string(10, &self.explorer_link)?;
        }
        if let Some(v) = self.factory_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolInfo {
        PoolInfo::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.token_a.clear();
        self.token_b.clear();
        self.name.clear();
        self.reserve_a.clear();
        self.reserve_b.clear();
        self.total_supply.clear();
        self.created_at.clear();
        self.block_created = 0;
        self.explorer_link.clear();
        self.factory_id.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolInfo {
        static instance: PoolInfo = PoolInfo {
            id: ::protobuf::MessageField::none(),
            token_a: ::protobuf::MessageField::none(),
            token_b: ::protobuf::MessageField::none(),
            name: ::std::string::String::new(),
            reserve_a: ::protobuf::MessageField::none(),
            reserve_b: ::protobuf::MessageField::none(),
            total_supply: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            block_created: 0,
            explorer_link: ::std::string::String::new(),
            factory_id: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolMetrics)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolMetrics {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolMetrics.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.tvl)
    pub tvl: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.tvl_change_1h)
    pub tvl_change_1h: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.tvl_change_24h)
    pub tvl_change_24h: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.tvl_change_7d)
    pub tvl_change_7d: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.tvl_change_30d)
    pub tvl_change_30d: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.volume_1h)
    pub volume_1h: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.volume_24h)
    pub volume_24h: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.volume_7d)
    pub volume_7d: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.volume_30d)
    pub volume_30d: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.volume_all)
    pub volume_all: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.apr)
    pub apr: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.fees_earned_1h)
    pub fees_earned_1h: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.fees_earned_24h)
    pub fees_earned_24h: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.fees_earned_7d)
    pub fees_earned_7d: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.fees_earned_30d)
    pub fees_earned_30d: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolMetrics.fees_earned_all)
    pub fees_earned_all: ::protobuf::MessageField<Price>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolMetrics.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolMetrics {
    fn default() -> &'a PoolMetrics {
        <PoolMetrics as ::protobuf::Message>::default_instance()
    }
}

impl PoolMetrics {
    pub fn new() -> PoolMetrics {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(17);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PoolMetrics| { &m.pool_id },
            |m: &mut PoolMetrics| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "tvl",
            |m: &PoolMetrics| { &m.tvl },
            |m: &mut PoolMetrics| { &mut m.tvl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "tvl_change_1h",
            |m: &PoolMetrics| { &m.tvl_change_1h },
            |m: &mut PoolMetrics| { &mut m.tvl_change_1h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "tvl_change_24h",
            |m: &PoolMetrics| { &m.tvl_change_24h },
            |m: &mut PoolMetrics| { &mut m.tvl_change_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "tvl_change_7d",
            |m: &PoolMetrics| { &m.tvl_change_7d },
            |m: &mut PoolMetrics| { &mut m.tvl_change_7d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "tvl_change_30d",
            |m: &PoolMetrics| { &m.tvl_change_30d },
            |m: &mut PoolMetrics| { &mut m.tvl_change_30d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_1h",
            |m: &PoolMetrics| { &m.volume_1h },
            |m: &mut PoolMetrics| { &mut m.volume_1h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_24h",
            |m: &PoolMetrics| { &m.volume_24h },
            |m: &mut PoolMetrics| { &mut m.volume_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_7d",
            |m: &PoolMetrics| { &m.volume_7d },
            |m: &mut PoolMetrics| { &mut m.volume_7d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_30d",
            |m: &PoolMetrics| { &m.volume_30d },
            |m: &mut PoolMetrics| { &mut m.volume_30d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume_all",
            |m: &PoolMetrics| { &m.volume_all },
            |m: &mut PoolMetrics| { &mut m.volume_all },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "apr",
            |m: &PoolMetrics| { &m.apr },
            |m: &mut PoolMetrics| { &mut m.apr },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_1h",
            |m: &PoolMetrics| { &m.fees_earned_1h },
            |m: &mut PoolMetrics| { &mut m.fees_earned_1h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_24h",
            |m: &PoolMetrics| { &m.fees_earned_24h },
            |m: &mut PoolMetrics| { &mut m.fees_earned_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_7d",
            |m: &PoolMetrics| { &m.fees_earned_7d },
            |m: &mut PoolMetrics| { &mut m.fees_earned_7d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_30d",
            |m: &PoolMetrics| { &m.fees_earned_30d },
            |m: &mut PoolMetrics| { &mut m.fees_earned_30d },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_all",
            |m: &PoolMetrics| { &m.fees_earned_all },
            |m: &mut PoolMetrics| { &mut m.fees_earned_all },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolMetrics>(
            "PoolMetrics",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolMetrics {
    const NAME: &'static str = "PoolMetrics";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl_change_1h)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl_change_24h)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl_change_7d)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.tvl_change_30d)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_1h)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_24h)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_7d)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_30d)?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_all)?;
                },
                98 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.apr)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_1h)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_24h)?;
                },
                122 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_7d)?;
                },
                130 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_30d)?;
                },
                138 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_all)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl_change_1h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl_change_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl_change_7d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.tvl_change_30d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_1h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_7d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_30d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_all.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.apr.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_1h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_7d.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_30d.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_all.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.tvl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.tvl_change_1h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.tvl_change_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.tvl_change_7d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if let Some(v) = self.tvl_change_30d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.volume_1h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.volume_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.volume_7d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if let Some(v) = self.volume_30d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        if let Some(v) = self.volume_all.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if let Some(v) = self.apr.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(12, v, os)?;
        }
        if let Some(v) = self.fees_earned_1h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(13, v, os)?;
        }
        if let Some(v) = self.fees_earned_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(14, v, os)?;
        }
        if let Some(v) = self.fees_earned_7d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(15, v, os)?;
        }
        if let Some(v) = self.fees_earned_30d.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(16, v, os)?;
        }
        if let Some(v) = self.fees_earned_all.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(17, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolMetrics {
        PoolMetrics::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.tvl.clear();
        self.tvl_change_1h.clear();
        self.tvl_change_24h.clear();
        self.tvl_change_7d.clear();
        self.tvl_change_30d.clear();
        self.volume_1h.clear();
        self.volume_24h.clear();
        self.volume_7d.clear();
        self.volume_30d.clear();
        self.volume_all.clear();
        self.apr.clear();
        self.fees_earned_1h.clear();
        self.fees_earned_24h.clear();
        self.fees_earned_7d.clear();
        self.fees_earned_30d.clear();
        self.fees_earned_all.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolMetrics {
        static instance: PoolMetrics = PoolMetrics {
            pool_id: ::protobuf::MessageField::none(),
            tvl: ::protobuf::MessageField::none(),
            tvl_change_1h: ::protobuf::MessageField::none(),
            tvl_change_24h: ::protobuf::MessageField::none(),
            tvl_change_7d: ::protobuf::MessageField::none(),
            tvl_change_30d: ::protobuf::MessageField::none(),
            volume_1h: ::protobuf::MessageField::none(),
            volume_24h: ::protobuf::MessageField::none(),
            volume_7d: ::protobuf::MessageField::none(),
            volume_30d: ::protobuf::MessageField::none(),
            volume_all: ::protobuf::MessageField::none(),
            apr: ::protobuf::MessageField::none(),
            fees_earned_1h: ::protobuf::MessageField::none(),
            fees_earned_24h: ::protobuf::MessageField::none(),
            fees_earned_7d: ::protobuf::MessageField::none(),
            fees_earned_30d: ::protobuf::MessageField::none(),
            fees_earned_all: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolMetrics {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolMetrics").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolMetrics {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolMetrics {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolTransaction)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolTransaction {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolTransaction.tx_hash)
    pub tx_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.timestamp)
    pub timestamp: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.block_height)
    pub block_height: u32,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.type)
    pub type_: ::protobuf::EnumOrUnknown<TransactionType>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.from_address)
    pub from_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.to_address)
    pub to_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.token_amounts)
    pub token_amounts: ::std::vec::Vec<TokenAmount>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.total_value_usd)
    pub total_value_usd: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PoolTransaction.explorer_url)
    pub explorer_url: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolTransaction.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolTransaction {
    fn default() -> &'a PoolTransaction {
        <PoolTransaction as ::protobuf::Message>::default_instance()
    }
}

impl PoolTransaction {
    pub fn new() -> PoolTransaction {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_hash",
            |m: &PoolTransaction| { &m.tx_hash },
            |m: &mut PoolTransaction| { &mut m.tx_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PoolTransaction| { &m.pool_id },
            |m: &mut PoolTransaction| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "timestamp",
            |m: &PoolTransaction| { &m.timestamp },
            |m: &mut PoolTransaction| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &PoolTransaction| { &m.block_height },
            |m: &mut PoolTransaction| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &PoolTransaction| { &m.type_ },
            |m: &mut PoolTransaction| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_address",
            |m: &PoolTransaction| { &m.from_address },
            |m: &mut PoolTransaction| { &mut m.from_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_address",
            |m: &PoolTransaction| { &m.to_address },
            |m: &mut PoolTransaction| { &mut m.to_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "token_amounts",
            |m: &PoolTransaction| { &m.token_amounts },
            |m: &mut PoolTransaction| { &mut m.token_amounts },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "total_value_usd",
            |m: &PoolTransaction| { &m.total_value_usd },
            |m: &mut PoolTransaction| { &mut m.total_value_usd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "explorer_url",
            |m: &PoolTransaction| { &m.explorer_url },
            |m: &mut PoolTransaction| { &mut m.explorer_url },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolTransaction>(
            "PoolTransaction",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolTransaction {
    const NAME: &'static str = "PoolTransaction";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx_hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                32 => {
                    self.block_height = is.read_uint32()?;
                },
                40 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                50 => {
                    self.from_address = is.read_bytes()?;
                },
                58 => {
                    self.to_address = is.read_bytes()?;
                },
                66 => {
                    self.token_amounts.push(is.read_message()?);
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_value_usd)?;
                },
                82 => {
                    self.explorer_url = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.tx_hash);
        }
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.block_height);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(TransactionType::TX_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(5, self.type_.value());
        }
        if !self.from_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.from_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.to_address);
        }
        for value in &self.token_amounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.total_value_usd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.explorer_url.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.explorer_url);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tx_hash.is_empty() {
            os.write_bytes(1, &self.tx_hash)?;
        }
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if self.block_height != 0 {
            os.write_uint32(4, self.block_height)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(TransactionType::TX_UNKNOWN) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.from_address.is_empty() {
            os.write_bytes(6, &self.from_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(7, &self.to_address)?;
        }
        for v in &self.token_amounts {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        if let Some(v) = self.total_value_usd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.explorer_url.is_empty() {
            os.write_string(10, &self.explorer_url)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolTransaction {
        PoolTransaction::new()
    }

    fn clear(&mut self) {
        self.tx_hash.clear();
        self.pool_id.clear();
        self.timestamp.clear();
        self.block_height = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(TransactionType::TX_UNKNOWN);
        self.from_address.clear();
        self.to_address.clear();
        self.token_amounts.clear();
        self.total_value_usd.clear();
        self.explorer_url.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolTransaction {
        static instance: PoolTransaction = PoolTransaction {
            tx_hash: ::std::vec::Vec::new(),
            pool_id: ::protobuf::MessageField::none(),
            timestamp: ::protobuf::MessageField::none(),
            block_height: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            from_address: ::std::vec::Vec::new(),
            to_address: ::std::vec::Vec::new(),
            token_amounts: ::std::vec::Vec::new(),
            total_value_usd: ::protobuf::MessageField::none(),
            explorer_url: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolTransaction {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolTransaction").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolTransaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolTransaction {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenAmount)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenAmount {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenAmount.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenAmount.amount)
    pub amount: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.TokenAmount.value_usd)
    pub value_usd: ::protobuf::MessageField<Price>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenAmount.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenAmount {
    fn default() -> &'a TokenAmount {
        <TokenAmount as ::protobuf::Message>::default_instance()
    }
}

impl TokenAmount {
    pub fn new() -> TokenAmount {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenAmount| { &m.token_id },
            |m: &mut TokenAmount| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "amount",
            |m: &TokenAmount| { &m.amount },
            |m: &mut TokenAmount| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "value_usd",
            |m: &TokenAmount| { &m.value_usd },
            |m: &mut TokenAmount| { &mut m.value_usd },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenAmount>(
            "TokenAmount",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenAmount {
    const NAME: &'static str = "TokenAmount";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value_usd)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value_usd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.value_usd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenAmount {
        TokenAmount::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.amount.clear();
        self.value_usd.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenAmount {
        static instance: TokenAmount = TokenAmount {
            token_id: ::protobuf::MessageField::none(),
            amount: ::protobuf::MessageField::none(),
            value_usd: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenAmount {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenAmount").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenAmount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenAmount {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.Position)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct Position {
    // message fields
    // @@protoc_insertion_point(field:oyl.Position.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.Position.wallet_address)
    pub wallet_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.Position.lp_token_balance)
    pub lp_token_balance: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.Position.share_percent)
    pub share_percent: ::protobuf::MessageField<Percentage>,
    // @@protoc_insertion_point(field:oyl.Position.tokens_supplied)
    pub tokens_supplied: ::std::vec::Vec<TokenAmount>,
    // @@protoc_insertion_point(field:oyl.Position.fees_earned_realized)
    pub fees_earned_realized: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.Position.fees_earned_unrealized)
    pub fees_earned_unrealized: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.Position.created_at)
    pub created_at: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.Position.block_created)
    pub block_created: u32,
    // @@protoc_insertion_point(field:oyl.Position.last_updated)
    pub last_updated: ::protobuf::MessageField<Timestamp>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.Position.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a Position {
    fn default() -> &'a Position {
        <Position as ::protobuf::Message>::default_instance()
    }
}

impl Position {
    pub fn new() -> Position {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &Position| { &m.pool_id },
            |m: &mut Position| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet_address",
            |m: &Position| { &m.wallet_address },
            |m: &mut Position| { &mut m.wallet_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "lp_token_balance",
            |m: &Position| { &m.lp_token_balance },
            |m: &mut Position| { &mut m.lp_token_balance },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Percentage>(
            "share_percent",
            |m: &Position| { &m.share_percent },
            |m: &mut Position| { &mut m.share_percent },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tokens_supplied",
            |m: &Position| { &m.tokens_supplied },
            |m: &mut Position| { &mut m.tokens_supplied },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_realized",
            |m: &Position| { &m.fees_earned_realized },
            |m: &mut Position| { &mut m.fees_earned_realized },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "fees_earned_unrealized",
            |m: &Position| { &m.fees_earned_unrealized },
            |m: &mut Position| { &mut m.fees_earned_unrealized },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "created_at",
            |m: &Position| { &m.created_at },
            |m: &mut Position| { &mut m.created_at },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_created",
            |m: &Position| { &m.block_created },
            |m: &mut Position| { &mut m.block_created },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "last_updated",
            |m: &Position| { &m.last_updated },
            |m: &mut Position| { &mut m.last_updated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<Position>(
            "Position",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for Position {
    const NAME: &'static str = "Position";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                18 => {
                    self.wallet_address = is.read_bytes()?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.lp_token_balance)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.share_percent)?;
                },
                42 => {
                    self.tokens_supplied.push(is.read_message()?);
                },
                50 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_realized)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.fees_earned_unrealized)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.created_at)?;
                },
                72 => {
                    self.block_created = is.read_uint32()?;
                },
                82 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.last_updated)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.wallet_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.wallet_address);
        }
        if let Some(v) = self.lp_token_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.share_percent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tokens_supplied {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.fees_earned_realized.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.fees_earned_unrealized.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.created_at.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_created != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.block_created);
        }
        if let Some(v) = self.last_updated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if !self.wallet_address.is_empty() {
            os.write_bytes(2, &self.wallet_address)?;
        }
        if let Some(v) = self.lp_token_balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.share_percent.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        for v in &self.tokens_supplied {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if let Some(v) = self.fees_earned_realized.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        }
        if let Some(v) = self.fees_earned_unrealized.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.created_at.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if self.block_created != 0 {
            os.write_uint32(9, self.block_created)?;
        }
        if let Some(v) = self.last_updated.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(10, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> Position {
        Position::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.wallet_address.clear();
        self.lp_token_balance.clear();
        self.share_percent.clear();
        self.tokens_supplied.clear();
        self.fees_earned_realized.clear();
        self.fees_earned_unrealized.clear();
        self.created_at.clear();
        self.block_created = 0;
        self.last_updated.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static Position {
        static instance: Position = Position {
            pool_id: ::protobuf::MessageField::none(),
            wallet_address: ::std::vec::Vec::new(),
            lp_token_balance: ::protobuf::MessageField::none(),
            share_percent: ::protobuf::MessageField::none(),
            tokens_supplied: ::std::vec::Vec::new(),
            fees_earned_realized: ::protobuf::MessageField::none(),
            fees_earned_unrealized: ::protobuf::MessageField::none(),
            created_at: ::protobuf::MessageField::none(),
            block_created: 0,
            last_updated: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for Position {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("Position").unwrap()).clone()
    }
}

impl ::std::fmt::Display for Position {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Position {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityEvent)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityEvent {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityEvent.tx_hash)
    pub tx_hash: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.timestamp)
    pub timestamp: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.block_height)
    pub block_height: u32,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.type)
    pub type_: ::protobuf::EnumOrUnknown<ActivityType>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.from_address)
    pub from_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.to_address)
    pub to_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.amount)
    pub amount: ::protobuf::MessageField<super::alkanes::Uint128>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.value_usd)
    pub value_usd: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.explorer_url)
    pub explorer_url: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.ActivityEvent.additional_data)
    pub additional_data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityEvent.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityEvent {
    fn default() -> &'a ActivityEvent {
        <ActivityEvent as ::protobuf::Message>::default_instance()
    }
}

impl ActivityEvent {
    pub fn new() -> ActivityEvent {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tx_hash",
            |m: &ActivityEvent| { &m.tx_hash },
            |m: &mut ActivityEvent| { &mut m.tx_hash },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "timestamp",
            |m: &ActivityEvent| { &m.timestamp },
            |m: &mut ActivityEvent| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "block_height",
            |m: &ActivityEvent| { &m.block_height },
            |m: &mut ActivityEvent| { &mut m.block_height },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ActivityEvent| { &m.type_ },
            |m: &mut ActivityEvent| { &mut m.type_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "from_address",
            |m: &ActivityEvent| { &m.from_address },
            |m: &mut ActivityEvent| { &mut m.from_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "to_address",
            |m: &ActivityEvent| { &m.to_address },
            |m: &mut ActivityEvent| { &mut m.to_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &ActivityEvent| { &m.token_id },
            |m: &mut ActivityEvent| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "amount",
            |m: &ActivityEvent| { &m.amount },
            |m: &mut ActivityEvent| { &mut m.amount },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "value_usd",
            |m: &ActivityEvent| { &m.value_usd },
            |m: &mut ActivityEvent| { &mut m.value_usd },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "explorer_url",
            |m: &ActivityEvent| { &m.explorer_url },
            |m: &mut ActivityEvent| { &mut m.explorer_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &ActivityEvent| { &m.pool_id },
            |m: &mut ActivityEvent| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "additional_data",
            |m: &ActivityEvent| { &m.additional_data },
            |m: &mut ActivityEvent| { &mut m.additional_data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityEvent>(
            "ActivityEvent",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityEvent {
    const NAME: &'static str = "ActivityEvent";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.tx_hash = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                24 => {
                    self.block_height = is.read_uint32()?;
                },
                32 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                42 => {
                    self.from_address = is.read_bytes()?;
                },
                50 => {
                    self.to_address = is.read_bytes()?;
                },
                58 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                66 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.amount)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.value_usd)?;
                },
                82 => {
                    self.explorer_url = is.read_string()?;
                },
                90 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                98 => {
                    self.additional_data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.tx_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.tx_hash);
        }
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.block_height != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.block_height);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ActivityType::ACTIVITY_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(4, self.type_.value());
        }
        if !self.from_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.from_address);
        }
        if !self.to_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.to_address);
        }
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.amount.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.value_usd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.explorer_url.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.explorer_url);
        }
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.additional_data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.additional_data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.tx_hash.is_empty() {
            os.write_bytes(1, &self.tx_hash)?;
        }
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.block_height != 0 {
            os.write_uint32(3, self.block_height)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ActivityType::ACTIVITY_UNKNOWN) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        if !self.from_address.is_empty() {
            os.write_bytes(5, &self.from_address)?;
        }
        if !self.to_address.is_empty() {
            os.write_bytes(6, &self.to_address)?;
        }
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        }
        if let Some(v) = self.amount.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        }
        if let Some(v) = self.value_usd.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        }
        if !self.explorer_url.is_empty() {
            os.write_string(10, &self.explorer_url)?;
        }
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(11, v, os)?;
        }
        if !self.additional_data.is_empty() {
            os.write_bytes(12, &self.additional_data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityEvent {
        ActivityEvent::new()
    }

    fn clear(&mut self) {
        self.tx_hash.clear();
        self.timestamp.clear();
        self.block_height = 0;
        self.type_ = ::protobuf::EnumOrUnknown::new(ActivityType::ACTIVITY_UNKNOWN);
        self.from_address.clear();
        self.to_address.clear();
        self.token_id.clear();
        self.amount.clear();
        self.value_usd.clear();
        self.explorer_url.clear();
        self.pool_id.clear();
        self.additional_data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityEvent {
        static instance: ActivityEvent = ActivityEvent {
            tx_hash: ::std::vec::Vec::new(),
            timestamp: ::protobuf::MessageField::none(),
            block_height: 0,
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            from_address: ::std::vec::Vec::new(),
            to_address: ::std::vec::Vec::new(),
            token_id: ::protobuf::MessageField::none(),
            amount: ::protobuf::MessageField::none(),
            value_usd: ::protobuf::MessageField::none(),
            explorer_url: ::std::string::String::new(),
            pool_id: ::protobuf::MessageField::none(),
            additional_data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityEvent {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityEvent").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityEvent {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityFeed)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityFeed {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityFeed.events)
    pub events: ::std::vec::Vec<ActivityEvent>,
    // @@protoc_insertion_point(field:oyl.ActivityFeed.total_count)
    pub total_count: u64,
    // @@protoc_insertion_point(field:oyl.ActivityFeed.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.ActivityFeed.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityFeed.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityFeed {
    fn default() -> &'a ActivityFeed {
        <ActivityFeed as ::protobuf::Message>::default_instance()
    }
}

impl ActivityFeed {
    pub fn new() -> ActivityFeed {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "events",
            |m: &ActivityFeed| { &m.events },
            |m: &mut ActivityFeed| { &mut m.events },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_count",
            |m: &ActivityFeed| { &m.total_count },
            |m: &mut ActivityFeed| { &mut m.total_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &ActivityFeed| { &m.has_more },
            |m: &mut ActivityFeed| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &ActivityFeed| { &m.next_cursor },
            |m: &mut ActivityFeed| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityFeed>(
            "ActivityFeed",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityFeed {
    const NAME: &'static str = "ActivityFeed";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.events.push(is.read_message()?);
                },
                16 => {
                    self.total_count = is.read_uint64()?;
                },
                24 => {
                    self.has_more = is.read_bool()?;
                },
                34 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total_count != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.total_count);
        }
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.events {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.total_count != 0 {
            os.write_uint64(2, self.total_count)?;
        }
        if self.has_more != false {
            os.write_bool(3, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(4, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityFeed {
        ActivityFeed::new()
    }

    fn clear(&mut self) {
        self.events.clear();
        self.total_count = 0;
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityFeed {
        static instance: ActivityFeed = ActivityFeed {
            events: ::std::vec::Vec::new(),
            total_count: 0,
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityFeed {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityFeed").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityFeed {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityFeed {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PricePoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PricePoint {
    // message fields
    // @@protoc_insertion_point(field:oyl.PricePoint.timestamp)
    pub timestamp: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PricePoint.price)
    pub price: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.PricePoint.volume)
    pub volume: ::protobuf::MessageField<Volume>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PricePoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PricePoint {
    fn default() -> &'a PricePoint {
        <PricePoint as ::protobuf::Message>::default_instance()
    }
}

impl PricePoint {
    pub fn new() -> PricePoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "timestamp",
            |m: &PricePoint| { &m.timestamp },
            |m: &mut PricePoint| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "price",
            |m: &PricePoint| { &m.price },
            |m: &mut PricePoint| { &mut m.price },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume",
            |m: &PricePoint| { &m.volume },
            |m: &mut PricePoint| { &mut m.volume },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PricePoint>(
            "PricePoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PricePoint {
    const NAME: &'static str = "PricePoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.volume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PricePoint {
        PricePoint::new()
    }

    fn clear(&mut self) {
        self.timestamp.clear();
        self.price.clear();
        self.volume.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PricePoint {
        static instance: PricePoint = PricePoint {
            timestamp: ::protobuf::MessageField::none(),
            price: ::protobuf::MessageField::none(),
            volume: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PricePoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PricePoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PricePoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PricePoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PriceHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PriceHistory {
    // message fields
    // @@protoc_insertion_point(field:oyl.PriceHistory.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.PriceHistory.points)
    pub points: ::std::vec::Vec<PricePoint>,
    // @@protoc_insertion_point(field:oyl.PriceHistory.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PriceHistory.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PriceHistory.interval)
    pub interval: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PriceHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PriceHistory {
    fn default() -> &'a PriceHistory {
        <PriceHistory as ::protobuf::Message>::default_instance()
    }
}

impl PriceHistory {
    pub fn new() -> PriceHistory {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &PriceHistory| { &m.token_id },
            |m: &mut PriceHistory| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "points",
            |m: &PriceHistory| { &m.points },
            |m: &mut PriceHistory| { &mut m.points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &PriceHistory| { &m.start_time },
            |m: &mut PriceHistory| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &PriceHistory| { &m.end_time },
            |m: &mut PriceHistory| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &PriceHistory| { &m.interval },
            |m: &mut PriceHistory| { &mut m.interval },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PriceHistory>(
            "PriceHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PriceHistory {
    const NAME: &'static str = "PriceHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    self.points.push(is.read_message()?);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                42 => {
                    self.interval = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.interval);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.points {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(5, &self.interval)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PriceHistory {
        PriceHistory::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.points.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PriceHistory {
        static instance: PriceHistory = PriceHistory {
            token_id: ::protobuf::MessageField::none(),
            points: ::std::vec::Vec::new(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PriceHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PriceHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PriceHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PriceHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.VolumePoint)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumePoint {
    // message fields
    // @@protoc_insertion_point(field:oyl.VolumePoint.timestamp)
    pub timestamp: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.VolumePoint.volume)
    pub volume: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.VolumePoint.transaction_count)
    pub transaction_count: u32,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.VolumePoint.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumePoint {
    fn default() -> &'a VolumePoint {
        <VolumePoint as ::protobuf::Message>::default_instance()
    }
}

impl VolumePoint {
    pub fn new() -> VolumePoint {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "timestamp",
            |m: &VolumePoint| { &m.timestamp },
            |m: &mut VolumePoint| { &mut m.timestamp },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "volume",
            |m: &VolumePoint| { &m.volume },
            |m: &mut VolumePoint| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transaction_count",
            |m: &VolumePoint| { &m.transaction_count },
            |m: &mut VolumePoint| { &mut m.transaction_count },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumePoint>(
            "VolumePoint",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumePoint {
    const NAME: &'static str = "VolumePoint";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.timestamp)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume)?;
                },
                24 => {
                    self.transaction_count = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.timestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.transaction_count != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.transaction_count);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.timestamp.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.volume.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.transaction_count != 0 {
            os.write_uint32(3, self.transaction_count)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumePoint {
        VolumePoint::new()
    }

    fn clear(&mut self) {
        self.timestamp.clear();
        self.volume.clear();
        self.transaction_count = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumePoint {
        static instance: VolumePoint = VolumePoint {
            timestamp: ::protobuf::MessageField::none(),
            volume: ::protobuf::MessageField::none(),
            transaction_count: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumePoint {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumePoint").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumePoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumePoint {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.VolumeHistory)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VolumeHistory {
    // message fields
    // @@protoc_insertion_point(field:oyl.VolumeHistory.points)
    pub points: ::std::vec::Vec<VolumePoint>,
    // @@protoc_insertion_point(field:oyl.VolumeHistory.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.VolumeHistory.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.VolumeHistory.interval)
    pub interval: ::std::string::String,
    // message oneof groups
    pub target: ::std::option::Option<volume_history::Target>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.VolumeHistory.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VolumeHistory {
    fn default() -> &'a VolumeHistory {
        <VolumeHistory as ::protobuf::Message>::default_instance()
    }
}

impl VolumeHistory {
    pub fn new() -> VolumeHistory {
        ::std::default::Default::default()
    }

    // .oyl.TokenId token_id = 1;

    pub fn token_id(&self) -> &TokenId {
        match self.target {
            ::std::option::Option::Some(volume_history::Target::TokenId(ref v)) => v,
            _ => <TokenId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_token_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_token_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(volume_history::Target::TokenId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_token_id(&mut self, v: TokenId) {
        self.target = ::std::option::Option::Some(volume_history::Target::TokenId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_token_id(&mut self) -> &mut TokenId {
        if let ::std::option::Option::Some(volume_history::Target::TokenId(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(volume_history::Target::TokenId(TokenId::new()));
        }
        match self.target {
            ::std::option::Option::Some(volume_history::Target::TokenId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_token_id(&mut self) -> TokenId {
        if self.has_token_id() {
            match self.target.take() {
                ::std::option::Option::Some(volume_history::Target::TokenId(v)) => v,
                _ => panic!(),
            }
        } else {
            TokenId::new()
        }
    }

    // .oyl.PoolId pool_id = 2;

    pub fn pool_id(&self) -> &PoolId {
        match self.target {
            ::std::option::Option::Some(volume_history::Target::PoolId(ref v)) => v,
            _ => <PoolId as ::protobuf::Message>::default_instance(),
        }
    }

    pub fn clear_pool_id(&mut self) {
        self.target = ::std::option::Option::None;
    }

    pub fn has_pool_id(&self) -> bool {
        match self.target {
            ::std::option::Option::Some(volume_history::Target::PoolId(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_pool_id(&mut self, v: PoolId) {
        self.target = ::std::option::Option::Some(volume_history::Target::PoolId(v))
    }

    // Mutable pointer to the field.
    pub fn mut_pool_id(&mut self) -> &mut PoolId {
        if let ::std::option::Option::Some(volume_history::Target::PoolId(_)) = self.target {
        } else {
            self.target = ::std::option::Option::Some(volume_history::Target::PoolId(PoolId::new()));
        }
        match self.target {
            ::std::option::Option::Some(volume_history::Target::PoolId(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_pool_id(&mut self) -> PoolId {
        if self.has_pool_id() {
            match self.target.take() {
                ::std::option::Option::Some(volume_history::Target::PoolId(v)) => v,
                _ => panic!(),
            }
        } else {
            PoolId::new()
        }
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(1);
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, TokenId>(
            "token_id",
            VolumeHistory::has_token_id,
            VolumeHistory::token_id,
            VolumeHistory::mut_token_id,
            VolumeHistory::set_token_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_oneof_message_has_get_mut_set_accessor::<_, PoolId>(
            "pool_id",
            VolumeHistory::has_pool_id,
            VolumeHistory::pool_id,
            VolumeHistory::mut_pool_id,
            VolumeHistory::set_pool_id,
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "points",
            |m: &VolumeHistory| { &m.points },
            |m: &mut VolumeHistory| { &mut m.points },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &VolumeHistory| { &m.start_time },
            |m: &mut VolumeHistory| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &VolumeHistory| { &m.end_time },
            |m: &mut VolumeHistory| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &VolumeHistory| { &m.interval },
            |m: &mut VolumeHistory| { &mut m.interval },
        ));
        oneofs.push(volume_history::Target::generated_oneof_descriptor_data());
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VolumeHistory>(
            "VolumeHistory",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VolumeHistory {
    const NAME: &'static str = "VolumeHistory";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.target = ::std::option::Option::Some(volume_history::Target::TokenId(is.read_message()?));
                },
                18 => {
                    self.target = ::std::option::Option::Some(volume_history::Target::PoolId(is.read_message()?));
                },
                26 => {
                    self.points.push(is.read_message()?);
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                50 => {
                    self.interval = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.points {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.interval);
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &volume_history::Target::TokenId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
                &volume_history::Target::PoolId(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.points {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(6, &self.interval)?;
        }
        if let ::std::option::Option::Some(ref v) = self.target {
            match v {
                &volume_history::Target::TokenId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
                },
                &volume_history::Target::PoolId(ref v) => {
                    ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
                },
            };
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VolumeHistory {
        VolumeHistory::new()
    }

    fn clear(&mut self) {
        self.target = ::std::option::Option::None;
        self.target = ::std::option::Option::None;
        self.points.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VolumeHistory {
        static instance: VolumeHistory = VolumeHistory {
            points: ::std::vec::Vec::new(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            target: ::std::option::Option::None,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VolumeHistory {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VolumeHistory").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VolumeHistory {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeHistory {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

/// Nested message and enums of message `VolumeHistory`
pub mod volume_history {

    #[derive(Clone,PartialEq,Debug)]
    #[non_exhaustive]
    // @@protoc_insertion_point(oneof:oyl.VolumeHistory.target)
    pub enum Target {
        // @@protoc_insertion_point(oneof_field:oyl.VolumeHistory.token_id)
        TokenId(super::TokenId),
        // @@protoc_insertion_point(oneof_field:oyl.VolumeHistory.pool_id)
        PoolId(super::PoolId),
    }

    impl ::protobuf::Oneof for Target {
    }

    impl ::protobuf::OneofFull for Target {
        fn descriptor() -> ::protobuf::reflect::OneofDescriptor {
            static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::OneofDescriptor> = ::protobuf::rt::Lazy::new();
            descriptor.get(|| <super::VolumeHistory as ::protobuf::MessageFull>::descriptor().oneof_by_name("target").unwrap()).clone()
        }
    }

    impl Target {
        pub(in super) fn generated_oneof_descriptor_data() -> ::protobuf::reflect::GeneratedOneofDescriptorData {
            ::protobuf::reflect::GeneratedOneofDescriptorData::new::<Target>("target")
        }
    }
}

// @@protoc_insertion_point(message:oyl.TokenInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenInfoRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenInfoRequest.include_metrics)
    pub include_metrics: bool,
    // @@protoc_insertion_point(field:oyl.TokenInfoRequest.include_price)
    pub include_price: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenInfoRequest {
    fn default() -> &'a TokenInfoRequest {
        <TokenInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokenInfoRequest {
    pub fn new() -> TokenInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenInfoRequest| { &m.token_id },
            |m: &mut TokenInfoRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_metrics",
            |m: &TokenInfoRequest| { &m.include_metrics },
            |m: &mut TokenInfoRequest| { &mut m.include_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_price",
            |m: &TokenInfoRequest| { &m.include_price },
            |m: &mut TokenInfoRequest| { &mut m.include_price },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenInfoRequest>(
            "TokenInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenInfoRequest {
    const NAME: &'static str = "TokenInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                16 => {
                    self.include_metrics = is.read_bool()?;
                },
                24 => {
                    self.include_price = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.include_metrics != false {
            my_size += 1 + 1;
        }
        if self.include_price != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.include_metrics != false {
            os.write_bool(2, self.include_metrics)?;
        }
        if self.include_price != false {
            os.write_bool(3, self.include_price)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenInfoRequest {
        TokenInfoRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.include_metrics = false;
        self.include_price = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenInfoRequest {
        static instance: TokenInfoRequest = TokenInfoRequest {
            token_id: ::protobuf::MessageField::none(),
            include_metrics: false,
            include_price: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenInfoResponse.token)
    pub token: ::protobuf::MessageField<TokenInfo>,
    // @@protoc_insertion_point(field:oyl.TokenInfoResponse.metrics)
    pub metrics: ::protobuf::MessageField<TokenMetrics>,
    // @@protoc_insertion_point(field:oyl.TokenInfoResponse.price)
    pub price: ::protobuf::MessageField<TokenPrice>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenInfoResponse {
    fn default() -> &'a TokenInfoResponse {
        <TokenInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokenInfoResponse {
    pub fn new() -> TokenInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenInfo>(
            "token",
            |m: &TokenInfoResponse| { &m.token },
            |m: &mut TokenInfoResponse| { &mut m.token },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenMetrics>(
            "metrics",
            |m: &TokenInfoResponse| { &m.metrics },
            |m: &mut TokenInfoResponse| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenPrice>(
            "price",
            |m: &TokenInfoResponse| { &m.price },
            |m: &mut TokenInfoResponse| { &mut m.price },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenInfoResponse>(
            "TokenInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenInfoResponse {
    const NAME: &'static str = "TokenInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.price.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.price.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenInfoResponse {
        TokenInfoResponse::new()
    }

    fn clear(&mut self) {
        self.token.clear();
        self.metrics.clear();
        self.price.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenInfoResponse {
        static instance: TokenInfoResponse = TokenInfoResponse {
            token: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            price: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokensByHolderRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokensByHolderRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokensByHolderRequest.wallet_address)
    pub wallet_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.TokensByHolderRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.TokensByHolderRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.TokensByHolderRequest.include_zero_balances)
    pub include_zero_balances: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokensByHolderRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokensByHolderRequest {
    fn default() -> &'a TokensByHolderRequest {
        <TokensByHolderRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokensByHolderRequest {
    pub fn new() -> TokensByHolderRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet_address",
            |m: &TokensByHolderRequest| { &m.wallet_address },
            |m: &mut TokensByHolderRequest| { &mut m.wallet_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &TokensByHolderRequest| { &m.limit },
            |m: &mut TokensByHolderRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &TokensByHolderRequest| { &m.cursor },
            |m: &mut TokensByHolderRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_zero_balances",
            |m: &TokensByHolderRequest| { &m.include_zero_balances },
            |m: &mut TokensByHolderRequest| { &mut m.include_zero_balances },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokensByHolderRequest>(
            "TokensByHolderRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokensByHolderRequest {
    const NAME: &'static str = "TokensByHolderRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wallet_address = is.read_bytes()?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    self.cursor = is.read_bytes()?;
                },
                32 => {
                    self.include_zero_balances = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wallet_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_address);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cursor);
        }
        if self.include_zero_balances != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wallet_address.is_empty() {
            os.write_bytes(1, &self.wallet_address)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(3, &self.cursor)?;
        }
        if self.include_zero_balances != false {
            os.write_bool(4, self.include_zero_balances)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokensByHolderRequest {
        TokensByHolderRequest::new()
    }

    fn clear(&mut self) {
        self.wallet_address.clear();
        self.limit = 0;
        self.cursor.clear();
        self.include_zero_balances = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokensByHolderRequest {
        static instance: TokensByHolderRequest = TokensByHolderRequest {
            wallet_address: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            include_zero_balances: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokensByHolderRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokensByHolderRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokensByHolderRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokensByHolderRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokensByHolderResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokensByHolderResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokensByHolderResponse.holdings)
    pub holdings: ::std::vec::Vec<TokenHolder>,
    // @@protoc_insertion_point(field:oyl.TokensByHolderResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.TokensByHolderResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokensByHolderResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokensByHolderResponse {
    fn default() -> &'a TokensByHolderResponse {
        <TokensByHolderResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokensByHolderResponse {
    pub fn new() -> TokensByHolderResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "holdings",
            |m: &TokensByHolderResponse| { &m.holdings },
            |m: &mut TokensByHolderResponse| { &mut m.holdings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &TokensByHolderResponse| { &m.has_more },
            |m: &mut TokensByHolderResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &TokensByHolderResponse| { &m.next_cursor },
            |m: &mut TokensByHolderResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokensByHolderResponse>(
            "TokensByHolderResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokensByHolderResponse {
    const NAME: &'static str = "TokensByHolderResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.holdings.push(is.read_message()?);
                },
                16 => {
                    self.has_more = is.read_bool()?;
                },
                26 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.holdings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.holdings {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.has_more != false {
            os.write_bool(2, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(3, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokensByHolderResponse {
        TokensByHolderResponse::new()
    }

    fn clear(&mut self) {
        self.holdings.clear();
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokensByHolderResponse {
        static instance: TokensByHolderResponse = TokensByHolderResponse {
            holdings: ::std::vec::Vec::new(),
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokensByHolderResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokensByHolderResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokensByHolderResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokensByHolderResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenHoldersRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenHoldersRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenHoldersRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenHoldersRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.TokenHoldersRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.TokenHoldersRequest.min_balance)
    pub min_balance: ::protobuf::MessageField<super::alkanes::Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenHoldersRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenHoldersRequest {
    fn default() -> &'a TokenHoldersRequest {
        <TokenHoldersRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokenHoldersRequest {
    pub fn new() -> TokenHoldersRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenHoldersRequest| { &m.token_id },
            |m: &mut TokenHoldersRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &TokenHoldersRequest| { &m.limit },
            |m: &mut TokenHoldersRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &TokenHoldersRequest| { &m.cursor },
            |m: &mut TokenHoldersRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "min_balance",
            |m: &TokenHoldersRequest| { &m.min_balance },
            |m: &mut TokenHoldersRequest| { &mut m.min_balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenHoldersRequest>(
            "TokenHoldersRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenHoldersRequest {
    const NAME: &'static str = "TokenHoldersRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    self.cursor = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min_balance)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cursor);
        }
        if let Some(v) = self.min_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(3, &self.cursor)?;
        }
        if let Some(v) = self.min_balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenHoldersRequest {
        TokenHoldersRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.limit = 0;
        self.cursor.clear();
        self.min_balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenHoldersRequest {
        static instance: TokenHoldersRequest = TokenHoldersRequest {
            token_id: ::protobuf::MessageField::none(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            min_balance: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenHoldersRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenHoldersRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenHoldersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenHoldersRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenHoldersResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenHoldersResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenHoldersResponse.holders)
    pub holders: ::std::vec::Vec<TokenHolder>,
    // @@protoc_insertion_point(field:oyl.TokenHoldersResponse.total_holders)
    pub total_holders: u64,
    // @@protoc_insertion_point(field:oyl.TokenHoldersResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.TokenHoldersResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenHoldersResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenHoldersResponse {
    fn default() -> &'a TokenHoldersResponse {
        <TokenHoldersResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokenHoldersResponse {
    pub fn new() -> TokenHoldersResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "holders",
            |m: &TokenHoldersResponse| { &m.holders },
            |m: &mut TokenHoldersResponse| { &mut m.holders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_holders",
            |m: &TokenHoldersResponse| { &m.total_holders },
            |m: &mut TokenHoldersResponse| { &mut m.total_holders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &TokenHoldersResponse| { &m.has_more },
            |m: &mut TokenHoldersResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &TokenHoldersResponse| { &m.next_cursor },
            |m: &mut TokenHoldersResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenHoldersResponse>(
            "TokenHoldersResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenHoldersResponse {
    const NAME: &'static str = "TokenHoldersResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.holders.push(is.read_message()?);
                },
                16 => {
                    self.total_holders = is.read_uint64()?;
                },
                24 => {
                    self.has_more = is.read_bool()?;
                },
                34 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.holders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total_holders != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.total_holders);
        }
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.holders {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.total_holders != 0 {
            os.write_uint64(2, self.total_holders)?;
        }
        if self.has_more != false {
            os.write_bool(3, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(4, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenHoldersResponse {
        TokenHoldersResponse::new()
    }

    fn clear(&mut self) {
        self.holders.clear();
        self.total_holders = 0;
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenHoldersResponse {
        static instance: TokenHoldersResponse = TokenHoldersResponse {
            holders: ::std::vec::Vec::new(),
            total_holders: 0,
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenHoldersResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenHoldersResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenHoldersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenHoldersResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenPriceHistoryRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenPriceHistoryRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryRequest.interval)
    pub interval: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryRequest.currency)
    pub currency: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenPriceHistoryRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenPriceHistoryRequest {
    fn default() -> &'a TokenPriceHistoryRequest {
        <TokenPriceHistoryRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokenPriceHistoryRequest {
    pub fn new() -> TokenPriceHistoryRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenPriceHistoryRequest| { &m.token_id },
            |m: &mut TokenPriceHistoryRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &TokenPriceHistoryRequest| { &m.start_time },
            |m: &mut TokenPriceHistoryRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &TokenPriceHistoryRequest| { &m.end_time },
            |m: &mut TokenPriceHistoryRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &TokenPriceHistoryRequest| { &m.interval },
            |m: &mut TokenPriceHistoryRequest| { &mut m.interval },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "currency",
            |m: &TokenPriceHistoryRequest| { &m.currency },
            |m: &mut TokenPriceHistoryRequest| { &mut m.currency },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenPriceHistoryRequest>(
            "TokenPriceHistoryRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenPriceHistoryRequest {
    const NAME: &'static str = "TokenPriceHistoryRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                34 => {
                    self.interval = is.read_string()?;
                },
                42 => {
                    self.currency = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.interval);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.currency);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(4, &self.interval)?;
        }
        if !self.currency.is_empty() {
            os.write_string(5, &self.currency)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenPriceHistoryRequest {
        TokenPriceHistoryRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.currency.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenPriceHistoryRequest {
        static instance: TokenPriceHistoryRequest = TokenPriceHistoryRequest {
            token_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            currency: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenPriceHistoryRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenPriceHistoryRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenPriceHistoryRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenPriceHistoryRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenPriceHistoryResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenPriceHistoryResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenPriceHistoryResponse.history)
    pub history: ::protobuf::MessageField<PriceHistory>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenPriceHistoryResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenPriceHistoryResponse {
    fn default() -> &'a TokenPriceHistoryResponse {
        <TokenPriceHistoryResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokenPriceHistoryResponse {
    pub fn new() -> TokenPriceHistoryResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PriceHistory>(
            "history",
            |m: &TokenPriceHistoryResponse| { &m.history },
            |m: &mut TokenPriceHistoryResponse| { &mut m.history },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenPriceHistoryResponse>(
            "TokenPriceHistoryResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenPriceHistoryResponse {
    const NAME: &'static str = "TokenPriceHistoryResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.history)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.history.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenPriceHistoryResponse {
        TokenPriceHistoryResponse::new()
    }

    fn clear(&mut self) {
        self.history.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenPriceHistoryResponse {
        static instance: TokenPriceHistoryResponse = TokenPriceHistoryResponse {
            history: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenPriceHistoryResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenPriceHistoryResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenPriceHistoryResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenPriceHistoryResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolInfoRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolInfoRequest.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolInfoRequest.include_metrics)
    pub include_metrics: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolInfoRequest {
    fn default() -> &'a PoolInfoRequest {
        <PoolInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl PoolInfoRequest {
    pub fn new() -> PoolInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PoolInfoRequest| { &m.pool_id },
            |m: &mut PoolInfoRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_metrics",
            |m: &PoolInfoRequest| { &m.include_metrics },
            |m: &mut PoolInfoRequest| { &mut m.include_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolInfoRequest>(
            "PoolInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolInfoRequest {
    const NAME: &'static str = "PoolInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                16 => {
                    self.include_metrics = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.include_metrics != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.include_metrics != false {
            os.write_bool(2, self.include_metrics)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolInfoRequest {
        PoolInfoRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.include_metrics = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolInfoRequest {
        static instance: PoolInfoRequest = PoolInfoRequest {
            pool_id: ::protobuf::MessageField::none(),
            include_metrics: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolInfoResponse.pool)
    pub pool: ::protobuf::MessageField<PoolInfo>,
    // @@protoc_insertion_point(field:oyl.PoolInfoResponse.metrics)
    pub metrics: ::protobuf::MessageField<PoolMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolInfoResponse {
    fn default() -> &'a PoolInfoResponse {
        <PoolInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoolInfoResponse {
    pub fn new() -> PoolInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolInfo>(
            "pool",
            |m: &PoolInfoResponse| { &m.pool },
            |m: &mut PoolInfoResponse| { &mut m.pool },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolMetrics>(
            "metrics",
            |m: &PoolInfoResponse| { &m.metrics },
            |m: &mut PoolInfoResponse| { &mut m.metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolInfoResponse>(
            "PoolInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolInfoResponse {
    const NAME: &'static str = "PoolInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolInfoResponse {
        PoolInfoResponse::new()
    }

    fn clear(&mut self) {
        self.pool.clear();
        self.metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolInfoResponse {
        static instance: PoolInfoResponse = PoolInfoResponse {
            pool: ::protobuf::MessageField::none(),
            metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolsByTokenRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolsByTokenRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolsByTokenRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenRequest.include_metrics)
    pub include_metrics: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolsByTokenRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolsByTokenRequest {
    fn default() -> &'a PoolsByTokenRequest {
        <PoolsByTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl PoolsByTokenRequest {
    pub fn new() -> PoolsByTokenRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &PoolsByTokenRequest| { &m.token_id },
            |m: &mut PoolsByTokenRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PoolsByTokenRequest| { &m.limit },
            |m: &mut PoolsByTokenRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &PoolsByTokenRequest| { &m.cursor },
            |m: &mut PoolsByTokenRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_metrics",
            |m: &PoolsByTokenRequest| { &m.include_metrics },
            |m: &mut PoolsByTokenRequest| { &mut m.include_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolsByTokenRequest>(
            "PoolsByTokenRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolsByTokenRequest {
    const NAME: &'static str = "PoolsByTokenRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    self.cursor = is.read_bytes()?;
                },
                32 => {
                    self.include_metrics = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cursor);
        }
        if self.include_metrics != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(3, &self.cursor)?;
        }
        if self.include_metrics != false {
            os.write_bool(4, self.include_metrics)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolsByTokenRequest {
        PoolsByTokenRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.limit = 0;
        self.cursor.clear();
        self.include_metrics = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolsByTokenRequest {
        static instance: PoolsByTokenRequest = PoolsByTokenRequest {
            token_id: ::protobuf::MessageField::none(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            include_metrics: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolsByTokenRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolsByTokenRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolsByTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolsByTokenRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolsByTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolsByTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolsByTokenResponse.pools)
    pub pools: ::std::vec::Vec<PoolInfo>,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenResponse.metrics)
    pub metrics: ::std::vec::Vec<PoolMetrics>,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.PoolsByTokenResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolsByTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolsByTokenResponse {
    fn default() -> &'a PoolsByTokenResponse {
        <PoolsByTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoolsByTokenResponse {
    pub fn new() -> PoolsByTokenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pools",
            |m: &PoolsByTokenResponse| { &m.pools },
            |m: &mut PoolsByTokenResponse| { &mut m.pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &PoolsByTokenResponse| { &m.metrics },
            |m: &mut PoolsByTokenResponse| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &PoolsByTokenResponse| { &m.has_more },
            |m: &mut PoolsByTokenResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &PoolsByTokenResponse| { &m.next_cursor },
            |m: &mut PoolsByTokenResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolsByTokenResponse>(
            "PoolsByTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolsByTokenResponse {
    const NAME: &'static str = "PoolsByTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pools.push(is.read_message()?);
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                24 => {
                    self.has_more = is.read_bool()?;
                },
                34 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pools {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.has_more != false {
            os.write_bool(3, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(4, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolsByTokenResponse {
        PoolsByTokenResponse::new()
    }

    fn clear(&mut self) {
        self.pools.clear();
        self.metrics.clear();
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolsByTokenResponse {
        static instance: PoolsByTokenResponse = PoolsByTokenResponse {
            pools: ::std::vec::Vec::new(),
            metrics: ::std::vec::Vec::new(),
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolsByTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolsByTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolsByTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolsByTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolTransactionsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolTransactionsRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<TransactionType>>,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolTransactionsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolTransactionsRequest {
    fn default() -> &'a PoolTransactionsRequest {
        <PoolTransactionsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PoolTransactionsRequest {
    pub fn new() -> PoolTransactionsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PoolTransactionsRequest| { &m.pool_id },
            |m: &mut PoolTransactionsRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &PoolTransactionsRequest| { &m.start_time },
            |m: &mut PoolTransactionsRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &PoolTransactionsRequest| { &m.end_time },
            |m: &mut PoolTransactionsRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &PoolTransactionsRequest| { &m.types },
            |m: &mut PoolTransactionsRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PoolTransactionsRequest| { &m.limit },
            |m: &mut PoolTransactionsRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &PoolTransactionsRequest| { &m.cursor },
            |m: &mut PoolTransactionsRequest| { &mut m.cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolTransactionsRequest>(
            "PoolTransactionsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolTransactionsRequest {
    const NAME: &'static str = "PoolTransactionsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                32 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                40 => {
                    self.limit = is.read_uint32()?;
                },
                50 => {
                    self.cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.types);
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_enum_or_unknown(4, &self.types)?;
        if self.limit != 0 {
            os.write_uint32(5, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(6, &self.cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolTransactionsRequest {
        PoolTransactionsRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.types.clear();
        self.limit = 0;
        self.cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolTransactionsRequest {
        static instance: PoolTransactionsRequest = PoolTransactionsRequest {
            pool_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            types: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolTransactionsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolTransactionsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolTransactionsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolTransactionsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolTransactionsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolTransactionsResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolTransactionsResponse.transactions)
    pub transactions: ::std::vec::Vec<PoolTransaction>,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.PoolTransactionsResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolTransactionsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolTransactionsResponse {
    fn default() -> &'a PoolTransactionsResponse {
        <PoolTransactionsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoolTransactionsResponse {
    pub fn new() -> PoolTransactionsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "transactions",
            |m: &PoolTransactionsResponse| { &m.transactions },
            |m: &mut PoolTransactionsResponse| { &mut m.transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &PoolTransactionsResponse| { &m.has_more },
            |m: &mut PoolTransactionsResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &PoolTransactionsResponse| { &m.next_cursor },
            |m: &mut PoolTransactionsResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolTransactionsResponse>(
            "PoolTransactionsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolTransactionsResponse {
    const NAME: &'static str = "PoolTransactionsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.transactions.push(is.read_message()?);
                },
                16 => {
                    self.has_more = is.read_bool()?;
                },
                26 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.transactions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.has_more != false {
            os.write_bool(2, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(3, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolTransactionsResponse {
        PoolTransactionsResponse::new()
    }

    fn clear(&mut self) {
        self.transactions.clear();
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolTransactionsResponse {
        static instance: PoolTransactionsResponse = PoolTransactionsResponse {
            transactions: ::std::vec::Vec::new(),
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolTransactionsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolTransactionsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolTransactionsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolTransactionsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.AllPoolsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllPoolsRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.AllPoolsRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.AllPoolsRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.AllPoolsRequest.include_metrics)
    pub include_metrics: bool,
    // @@protoc_insertion_point(field:oyl.AllPoolsRequest.sort_by)
    pub sort_by: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.AllPoolsRequest.descending)
    pub descending: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.AllPoolsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllPoolsRequest {
    fn default() -> &'a AllPoolsRequest {
        <AllPoolsRequest as ::protobuf::Message>::default_instance()
    }
}

impl AllPoolsRequest {
    pub fn new() -> AllPoolsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &AllPoolsRequest| { &m.limit },
            |m: &mut AllPoolsRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &AllPoolsRequest| { &m.cursor },
            |m: &mut AllPoolsRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_metrics",
            |m: &AllPoolsRequest| { &m.include_metrics },
            |m: &mut AllPoolsRequest| { &mut m.include_metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sort_by",
            |m: &AllPoolsRequest| { &m.sort_by },
            |m: &mut AllPoolsRequest| { &mut m.sort_by },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "descending",
            |m: &AllPoolsRequest| { &m.descending },
            |m: &mut AllPoolsRequest| { &mut m.descending },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllPoolsRequest>(
            "AllPoolsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllPoolsRequest {
    const NAME: &'static str = "AllPoolsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.limit = is.read_uint32()?;
                },
                18 => {
                    self.cursor = is.read_bytes()?;
                },
                24 => {
                    self.include_metrics = is.read_bool()?;
                },
                34 => {
                    self.sort_by = is.read_string()?;
                },
                40 => {
                    self.descending = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.cursor);
        }
        if self.include_metrics != false {
            my_size += 1 + 1;
        }
        if !self.sort_by.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.sort_by);
        }
        if self.descending != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.limit != 0 {
            os.write_uint32(1, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(2, &self.cursor)?;
        }
        if self.include_metrics != false {
            os.write_bool(3, self.include_metrics)?;
        }
        if !self.sort_by.is_empty() {
            os.write_string(4, &self.sort_by)?;
        }
        if self.descending != false {
            os.write_bool(5, self.descending)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllPoolsRequest {
        AllPoolsRequest::new()
    }

    fn clear(&mut self) {
        self.limit = 0;
        self.cursor.clear();
        self.include_metrics = false;
        self.sort_by.clear();
        self.descending = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllPoolsRequest {
        static instance: AllPoolsRequest = AllPoolsRequest {
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            include_metrics: false,
            sort_by: ::std::string::String::new(),
            descending: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllPoolsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllPoolsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllPoolsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllPoolsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.AllPoolsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AllPoolsResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.AllPoolsResponse.pools)
    pub pools: ::std::vec::Vec<PoolInfo>,
    // @@protoc_insertion_point(field:oyl.AllPoolsResponse.metrics)
    pub metrics: ::std::vec::Vec<PoolMetrics>,
    // @@protoc_insertion_point(field:oyl.AllPoolsResponse.total_pools)
    pub total_pools: u64,
    // @@protoc_insertion_point(field:oyl.AllPoolsResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.AllPoolsResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.AllPoolsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AllPoolsResponse {
    fn default() -> &'a AllPoolsResponse {
        <AllPoolsResponse as ::protobuf::Message>::default_instance()
    }
}

impl AllPoolsResponse {
    pub fn new() -> AllPoolsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pools",
            |m: &AllPoolsResponse| { &m.pools },
            |m: &mut AllPoolsResponse| { &mut m.pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "metrics",
            |m: &AllPoolsResponse| { &m.metrics },
            |m: &mut AllPoolsResponse| { &mut m.metrics },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pools",
            |m: &AllPoolsResponse| { &m.total_pools },
            |m: &mut AllPoolsResponse| { &mut m.total_pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &AllPoolsResponse| { &m.has_more },
            |m: &mut AllPoolsResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &AllPoolsResponse| { &m.next_cursor },
            |m: &mut AllPoolsResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AllPoolsResponse>(
            "AllPoolsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AllPoolsResponse {
    const NAME: &'static str = "AllPoolsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.pools.push(is.read_message()?);
                },
                18 => {
                    self.metrics.push(is.read_message()?);
                },
                24 => {
                    self.total_pools = is.read_uint64()?;
                },
                32 => {
                    self.has_more = is.read_bool()?;
                },
                42 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.metrics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total_pools != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total_pools);
        }
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.pools {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.metrics {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        if self.total_pools != 0 {
            os.write_uint64(3, self.total_pools)?;
        }
        if self.has_more != false {
            os.write_bool(4, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(5, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AllPoolsResponse {
        AllPoolsResponse::new()
    }

    fn clear(&mut self) {
        self.pools.clear();
        self.metrics.clear();
        self.total_pools = 0;
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AllPoolsResponse {
        static instance: AllPoolsResponse = AllPoolsResponse {
            pools: ::std::vec::Vec::new(),
            metrics: ::std::vec::Vec::new(),
            total_pools: 0,
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AllPoolsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AllPoolsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AllPoolsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllPoolsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PositionsByAddressRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsByAddressRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PositionsByAddressRequest.wallet_address)
    pub wallet_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PositionsByAddressRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.PositionsByAddressRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PositionsByAddressRequest.include_zero_positions)
    pub include_zero_positions: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PositionsByAddressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PositionsByAddressRequest {
    fn default() -> &'a PositionsByAddressRequest {
        <PositionsByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl PositionsByAddressRequest {
    pub fn new() -> PositionsByAddressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet_address",
            |m: &PositionsByAddressRequest| { &m.wallet_address },
            |m: &mut PositionsByAddressRequest| { &mut m.wallet_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PositionsByAddressRequest| { &m.limit },
            |m: &mut PositionsByAddressRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &PositionsByAddressRequest| { &m.cursor },
            |m: &mut PositionsByAddressRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "include_zero_positions",
            |m: &PositionsByAddressRequest| { &m.include_zero_positions },
            |m: &mut PositionsByAddressRequest| { &mut m.include_zero_positions },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionsByAddressRequest>(
            "PositionsByAddressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PositionsByAddressRequest {
    const NAME: &'static str = "PositionsByAddressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wallet_address = is.read_bytes()?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    self.cursor = is.read_bytes()?;
                },
                32 => {
                    self.include_zero_positions = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wallet_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_address);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cursor);
        }
        if self.include_zero_positions != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wallet_address.is_empty() {
            os.write_bytes(1, &self.wallet_address)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(3, &self.cursor)?;
        }
        if self.include_zero_positions != false {
            os.write_bool(4, self.include_zero_positions)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PositionsByAddressRequest {
        PositionsByAddressRequest::new()
    }

    fn clear(&mut self) {
        self.wallet_address.clear();
        self.limit = 0;
        self.cursor.clear();
        self.include_zero_positions = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PositionsByAddressRequest {
        static instance: PositionsByAddressRequest = PositionsByAddressRequest {
            wallet_address: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            include_zero_positions: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PositionsByAddressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PositionsByAddressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PositionsByAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsByAddressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PositionsByAddressResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsByAddressResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PositionsByAddressResponse.positions)
    pub positions: ::std::vec::Vec<Position>,
    // @@protoc_insertion_point(field:oyl.PositionsByAddressResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.PositionsByAddressResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PositionsByAddressResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PositionsByAddressResponse {
    fn default() -> &'a PositionsByAddressResponse {
        <PositionsByAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl PositionsByAddressResponse {
    pub fn new() -> PositionsByAddressResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positions",
            |m: &PositionsByAddressResponse| { &m.positions },
            |m: &mut PositionsByAddressResponse| { &mut m.positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &PositionsByAddressResponse| { &m.has_more },
            |m: &mut PositionsByAddressResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &PositionsByAddressResponse| { &m.next_cursor },
            |m: &mut PositionsByAddressResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionsByAddressResponse>(
            "PositionsByAddressResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PositionsByAddressResponse {
    const NAME: &'static str = "PositionsByAddressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.positions.push(is.read_message()?);
                },
                16 => {
                    self.has_more = is.read_bool()?;
                },
                26 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.positions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.has_more != false {
            os.write_bool(2, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(3, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PositionsByAddressResponse {
        PositionsByAddressResponse::new()
    }

    fn clear(&mut self) {
        self.positions.clear();
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PositionsByAddressResponse {
        static instance: PositionsByAddressResponse = PositionsByAddressResponse {
            positions: ::std::vec::Vec::new(),
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PositionsByAddressResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PositionsByAddressResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PositionsByAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsByAddressResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PositionsByPoolRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsByPoolRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PositionsByPoolRequest.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolRequest.min_lp_balance)
    pub min_lp_balance: ::protobuf::MessageField<super::alkanes::Uint128>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PositionsByPoolRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PositionsByPoolRequest {
    fn default() -> &'a PositionsByPoolRequest {
        <PositionsByPoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl PositionsByPoolRequest {
    pub fn new() -> PositionsByPoolRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PositionsByPoolRequest| { &m.pool_id },
            |m: &mut PositionsByPoolRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &PositionsByPoolRequest| { &m.limit },
            |m: &mut PositionsByPoolRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &PositionsByPoolRequest| { &m.cursor },
            |m: &mut PositionsByPoolRequest| { &mut m.cursor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, super::alkanes::Uint128>(
            "min_lp_balance",
            |m: &PositionsByPoolRequest| { &m.min_lp_balance },
            |m: &mut PositionsByPoolRequest| { &mut m.min_lp_balance },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionsByPoolRequest>(
            "PositionsByPoolRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PositionsByPoolRequest {
    const NAME: &'static str = "PositionsByPoolRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    self.cursor = is.read_bytes()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.min_lp_balance)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.cursor);
        }
        if let Some(v) = self.min_lp_balance.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(3, &self.cursor)?;
        }
        if let Some(v) = self.min_lp_balance.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PositionsByPoolRequest {
        PositionsByPoolRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.limit = 0;
        self.cursor.clear();
        self.min_lp_balance.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PositionsByPoolRequest {
        static instance: PositionsByPoolRequest = PositionsByPoolRequest {
            pool_id: ::protobuf::MessageField::none(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            min_lp_balance: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PositionsByPoolRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PositionsByPoolRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PositionsByPoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsByPoolRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PositionsByPoolResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PositionsByPoolResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PositionsByPoolResponse.positions)
    pub positions: ::std::vec::Vec<Position>,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolResponse.total_positions)
    pub total_positions: u64,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolResponse.has_more)
    pub has_more: bool,
    // @@protoc_insertion_point(field:oyl.PositionsByPoolResponse.next_cursor)
    pub next_cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PositionsByPoolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PositionsByPoolResponse {
    fn default() -> &'a PositionsByPoolResponse {
        <PositionsByPoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl PositionsByPoolResponse {
    pub fn new() -> PositionsByPoolResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "positions",
            |m: &PositionsByPoolResponse| { &m.positions },
            |m: &mut PositionsByPoolResponse| { &mut m.positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_positions",
            |m: &PositionsByPoolResponse| { &m.total_positions },
            |m: &mut PositionsByPoolResponse| { &mut m.total_positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_more",
            |m: &PositionsByPoolResponse| { &m.has_more },
            |m: &mut PositionsByPoolResponse| { &mut m.has_more },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "next_cursor",
            |m: &PositionsByPoolResponse| { &m.next_cursor },
            |m: &mut PositionsByPoolResponse| { &mut m.next_cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PositionsByPoolResponse>(
            "PositionsByPoolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PositionsByPoolResponse {
    const NAME: &'static str = "PositionsByPoolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.positions.push(is.read_message()?);
                },
                16 => {
                    self.total_positions = is.read_uint64()?;
                },
                24 => {
                    self.has_more = is.read_bool()?;
                },
                34 => {
                    self.next_cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.total_positions != 0 {
            my_size += ::protobuf::rt::uint64_size(2, self.total_positions);
        }
        if self.has_more != false {
            my_size += 1 + 1;
        }
        if !self.next_cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.next_cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.positions {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        if self.total_positions != 0 {
            os.write_uint64(2, self.total_positions)?;
        }
        if self.has_more != false {
            os.write_bool(3, self.has_more)?;
        }
        if !self.next_cursor.is_empty() {
            os.write_bytes(4, &self.next_cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PositionsByPoolResponse {
        PositionsByPoolResponse::new()
    }

    fn clear(&mut self) {
        self.positions.clear();
        self.total_positions = 0;
        self.has_more = false;
        self.next_cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PositionsByPoolResponse {
        static instance: PositionsByPoolResponse = PositionsByPoolResponse {
            positions: ::std::vec::Vec::new(),
            total_positions: 0,
            has_more: false,
            next_cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PositionsByPoolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PositionsByPoolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PositionsByPoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PositionsByPoolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByTokenRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByTokenRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<ActivityType>>,
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.ActivityByTokenRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByTokenRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByTokenRequest {
    fn default() -> &'a ActivityByTokenRequest {
        <ActivityByTokenRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByTokenRequest {
    pub fn new() -> ActivityByTokenRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &ActivityByTokenRequest| { &m.token_id },
            |m: &mut ActivityByTokenRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &ActivityByTokenRequest| { &m.start_time },
            |m: &mut ActivityByTokenRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &ActivityByTokenRequest| { &m.end_time },
            |m: &mut ActivityByTokenRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ActivityByTokenRequest| { &m.types },
            |m: &mut ActivityByTokenRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ActivityByTokenRequest| { &m.limit },
            |m: &mut ActivityByTokenRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ActivityByTokenRequest| { &m.cursor },
            |m: &mut ActivityByTokenRequest| { &mut m.cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByTokenRequest>(
            "ActivityByTokenRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByTokenRequest {
    const NAME: &'static str = "ActivityByTokenRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                32 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                40 => {
                    self.limit = is.read_uint32()?;
                },
                50 => {
                    self.cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.types);
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_enum_or_unknown(4, &self.types)?;
        if self.limit != 0 {
            os.write_uint32(5, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(6, &self.cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByTokenRequest {
        ActivityByTokenRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.types.clear();
        self.limit = 0;
        self.cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByTokenRequest {
        static instance: ActivityByTokenRequest = ActivityByTokenRequest {
            token_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            types: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByTokenRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByTokenRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByTokenRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByTokenRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByTokenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByTokenResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByTokenResponse.feed)
    pub feed: ::protobuf::MessageField<ActivityFeed>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByTokenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByTokenResponse {
    fn default() -> &'a ActivityByTokenResponse {
        <ActivityByTokenResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByTokenResponse {
    pub fn new() -> ActivityByTokenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActivityFeed>(
            "feed",
            |m: &ActivityByTokenResponse| { &m.feed },
            |m: &mut ActivityByTokenResponse| { &mut m.feed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByTokenResponse>(
            "ActivityByTokenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByTokenResponse {
    const NAME: &'static str = "ActivityByTokenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.feed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByTokenResponse {
        ActivityByTokenResponse::new()
    }

    fn clear(&mut self) {
        self.feed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByTokenResponse {
        static instance: ActivityByTokenResponse = ActivityByTokenResponse {
            feed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByTokenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByTokenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByTokenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByTokenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByAddressRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByAddressRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.wallet_address)
    pub wallet_address: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<ActivityType>>,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.token_filter)
    pub token_filter: ::std::vec::Vec<TokenId>,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.ActivityByAddressRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByAddressRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByAddressRequest {
    fn default() -> &'a ActivityByAddressRequest {
        <ActivityByAddressRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByAddressRequest {
    pub fn new() -> ActivityByAddressRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wallet_address",
            |m: &ActivityByAddressRequest| { &m.wallet_address },
            |m: &mut ActivityByAddressRequest| { &mut m.wallet_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &ActivityByAddressRequest| { &m.start_time },
            |m: &mut ActivityByAddressRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &ActivityByAddressRequest| { &m.end_time },
            |m: &mut ActivityByAddressRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ActivityByAddressRequest| { &m.types },
            |m: &mut ActivityByAddressRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "token_filter",
            |m: &ActivityByAddressRequest| { &m.token_filter },
            |m: &mut ActivityByAddressRequest| { &mut m.token_filter },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ActivityByAddressRequest| { &m.limit },
            |m: &mut ActivityByAddressRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ActivityByAddressRequest| { &m.cursor },
            |m: &mut ActivityByAddressRequest| { &mut m.cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByAddressRequest>(
            "ActivityByAddressRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByAddressRequest {
    const NAME: &'static str = "ActivityByAddressRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.wallet_address = is.read_bytes()?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                32 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                42 => {
                    self.token_filter.push(is.read_message()?);
                },
                48 => {
                    self.limit = is.read_uint32()?;
                },
                58 => {
                    self.cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.wallet_address.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.wallet_address);
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.types);
        for value in &self.token_filter {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.wallet_address.is_empty() {
            os.write_bytes(1, &self.wallet_address)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_enum_or_unknown(4, &self.types)?;
        for v in &self.token_filter {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        if self.limit != 0 {
            os.write_uint32(6, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(7, &self.cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByAddressRequest {
        ActivityByAddressRequest::new()
    }

    fn clear(&mut self) {
        self.wallet_address.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.types.clear();
        self.token_filter.clear();
        self.limit = 0;
        self.cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByAddressRequest {
        static instance: ActivityByAddressRequest = ActivityByAddressRequest {
            wallet_address: ::std::vec::Vec::new(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            types: ::std::vec::Vec::new(),
            token_filter: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByAddressRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByAddressRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByAddressRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByAddressRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByAddressResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByAddressResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByAddressResponse.feed)
    pub feed: ::protobuf::MessageField<ActivityFeed>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByAddressResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByAddressResponse {
    fn default() -> &'a ActivityByAddressResponse {
        <ActivityByAddressResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByAddressResponse {
    pub fn new() -> ActivityByAddressResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActivityFeed>(
            "feed",
            |m: &ActivityByAddressResponse| { &m.feed },
            |m: &mut ActivityByAddressResponse| { &mut m.feed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByAddressResponse>(
            "ActivityByAddressResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByAddressResponse {
    const NAME: &'static str = "ActivityByAddressResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.feed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByAddressResponse {
        ActivityByAddressResponse::new()
    }

    fn clear(&mut self) {
        self.feed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByAddressResponse {
        static instance: ActivityByAddressResponse = ActivityByAddressResponse {
            feed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByAddressResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByAddressResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByAddressResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByAddressResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByPoolRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByPoolRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.types)
    pub types: ::std::vec::Vec<::protobuf::EnumOrUnknown<ActivityType>>,
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:oyl.ActivityByPoolRequest.cursor)
    pub cursor: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByPoolRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByPoolRequest {
    fn default() -> &'a ActivityByPoolRequest {
        <ActivityByPoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByPoolRequest {
    pub fn new() -> ActivityByPoolRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &ActivityByPoolRequest| { &m.pool_id },
            |m: &mut ActivityByPoolRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &ActivityByPoolRequest| { &m.start_time },
            |m: &mut ActivityByPoolRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &ActivityByPoolRequest| { &m.end_time },
            |m: &mut ActivityByPoolRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "types",
            |m: &ActivityByPoolRequest| { &m.types },
            |m: &mut ActivityByPoolRequest| { &mut m.types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &ActivityByPoolRequest| { &m.limit },
            |m: &mut ActivityByPoolRequest| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cursor",
            |m: &ActivityByPoolRequest| { &m.cursor },
            |m: &mut ActivityByPoolRequest| { &mut m.cursor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByPoolRequest>(
            "ActivityByPoolRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByPoolRequest {
    const NAME: &'static str = "ActivityByPoolRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                32 => {
                    self.types.push(is.read_enum_or_unknown()?);
                },
                34 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.types)?
                },
                40 => {
                    self.limit = is.read_uint32()?;
                },
                50 => {
                    self.cursor = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(4, &self.types);
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.limit);
        }
        if !self.cursor.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.cursor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        os.write_repeated_packed_enum_or_unknown(4, &self.types)?;
        if self.limit != 0 {
            os.write_uint32(5, self.limit)?;
        }
        if !self.cursor.is_empty() {
            os.write_bytes(6, &self.cursor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByPoolRequest {
        ActivityByPoolRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.types.clear();
        self.limit = 0;
        self.cursor.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByPoolRequest {
        static instance: ActivityByPoolRequest = ActivityByPoolRequest {
            pool_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            types: ::std::vec::Vec::new(),
            limit: 0,
            cursor: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByPoolRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByPoolRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByPoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByPoolRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ActivityByPoolResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ActivityByPoolResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.ActivityByPoolResponse.feed)
    pub feed: ::protobuf::MessageField<ActivityFeed>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ActivityByPoolResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ActivityByPoolResponse {
    fn default() -> &'a ActivityByPoolResponse {
        <ActivityByPoolResponse as ::protobuf::Message>::default_instance()
    }
}

impl ActivityByPoolResponse {
    pub fn new() -> ActivityByPoolResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, ActivityFeed>(
            "feed",
            |m: &ActivityByPoolResponse| { &m.feed },
            |m: &mut ActivityByPoolResponse| { &mut m.feed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ActivityByPoolResponse>(
            "ActivityByPoolResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ActivityByPoolResponse {
    const NAME: &'static str = "ActivityByPoolResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.feed)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.feed.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.feed.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ActivityByPoolResponse {
        ActivityByPoolResponse::new()
    }

    fn clear(&mut self) {
        self.feed.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ActivityByPoolResponse {
        static instance: ActivityByPoolResponse = ActivityByPoolResponse {
            feed: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ActivityByPoolResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ActivityByPoolResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ActivityByPoolResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ActivityByPoolResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenAnalyticsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenAnalyticsRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsRequest.token_id)
    pub token_id: ::protobuf::MessageField<TokenId>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsRequest.interval)
    pub interval: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenAnalyticsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenAnalyticsRequest {
    fn default() -> &'a TokenAnalyticsRequest {
        <TokenAnalyticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl TokenAnalyticsRequest {
    pub fn new() -> TokenAnalyticsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenId>(
            "token_id",
            |m: &TokenAnalyticsRequest| { &m.token_id },
            |m: &mut TokenAnalyticsRequest| { &mut m.token_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &TokenAnalyticsRequest| { &m.start_time },
            |m: &mut TokenAnalyticsRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &TokenAnalyticsRequest| { &m.end_time },
            |m: &mut TokenAnalyticsRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &TokenAnalyticsRequest| { &m.interval },
            |m: &mut TokenAnalyticsRequest| { &mut m.interval },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenAnalyticsRequest>(
            "TokenAnalyticsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenAnalyticsRequest {
    const NAME: &'static str = "TokenAnalyticsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.token_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                34 => {
                    self.interval = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.token_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.interval);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.token_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(4, &self.interval)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenAnalyticsRequest {
        TokenAnalyticsRequest::new()
    }

    fn clear(&mut self) {
        self.token_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenAnalyticsRequest {
        static instance: TokenAnalyticsRequest = TokenAnalyticsRequest {
            token_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenAnalyticsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenAnalyticsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenAnalyticsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenAnalyticsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.TokenAnalyticsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TokenAnalyticsResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsResponse.price_history)
    pub price_history: ::protobuf::MessageField<PriceHistory>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsResponse.volume_history)
    pub volume_history: ::protobuf::MessageField<VolumeHistory>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsResponse.top_holders)
    pub top_holders: ::std::vec::Vec<TokenHolder>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsResponse.pools)
    pub pools: ::std::vec::Vec<PoolInfo>,
    // @@protoc_insertion_point(field:oyl.TokenAnalyticsResponse.current_metrics)
    pub current_metrics: ::protobuf::MessageField<TokenMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.TokenAnalyticsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TokenAnalyticsResponse {
    fn default() -> &'a TokenAnalyticsResponse {
        <TokenAnalyticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl TokenAnalyticsResponse {
    pub fn new() -> TokenAnalyticsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PriceHistory>(
            "price_history",
            |m: &TokenAnalyticsResponse| { &m.price_history },
            |m: &mut TokenAnalyticsResponse| { &mut m.price_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VolumeHistory>(
            "volume_history",
            |m: &TokenAnalyticsResponse| { &m.volume_history },
            |m: &mut TokenAnalyticsResponse| { &mut m.volume_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_holders",
            |m: &TokenAnalyticsResponse| { &m.top_holders },
            |m: &mut TokenAnalyticsResponse| { &mut m.top_holders },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "pools",
            |m: &TokenAnalyticsResponse| { &m.pools },
            |m: &mut TokenAnalyticsResponse| { &mut m.pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, TokenMetrics>(
            "current_metrics",
            |m: &TokenAnalyticsResponse| { &m.current_metrics },
            |m: &mut TokenAnalyticsResponse| { &mut m.current_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TokenAnalyticsResponse>(
            "TokenAnalyticsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TokenAnalyticsResponse {
    const NAME: &'static str = "TokenAnalyticsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.price_history)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_history)?;
                },
                26 => {
                    self.top_holders.push(is.read_message()?);
                },
                34 => {
                    self.pools.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.price_history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.volume_history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.top_holders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.price_history.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.volume_history.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        for v in &self.top_holders {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.pools {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.current_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TokenAnalyticsResponse {
        TokenAnalyticsResponse::new()
    }

    fn clear(&mut self) {
        self.price_history.clear();
        self.volume_history.clear();
        self.top_holders.clear();
        self.pools.clear();
        self.current_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TokenAnalyticsResponse {
        static instance: TokenAnalyticsResponse = TokenAnalyticsResponse {
            price_history: ::protobuf::MessageField::none(),
            volume_history: ::protobuf::MessageField::none(),
            top_holders: ::std::vec::Vec::new(),
            pools: ::std::vec::Vec::new(),
            current_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TokenAnalyticsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TokenAnalyticsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TokenAnalyticsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenAnalyticsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolAnalyticsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolAnalyticsRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsRequest.pool_id)
    pub pool_id: ::protobuf::MessageField<PoolId>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsRequest.interval)
    pub interval: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolAnalyticsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolAnalyticsRequest {
    fn default() -> &'a PoolAnalyticsRequest {
        <PoolAnalyticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl PoolAnalyticsRequest {
    pub fn new() -> PoolAnalyticsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolId>(
            "pool_id",
            |m: &PoolAnalyticsRequest| { &m.pool_id },
            |m: &mut PoolAnalyticsRequest| { &mut m.pool_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &PoolAnalyticsRequest| { &m.start_time },
            |m: &mut PoolAnalyticsRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &PoolAnalyticsRequest| { &m.end_time },
            |m: &mut PoolAnalyticsRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &PoolAnalyticsRequest| { &m.interval },
            |m: &mut PoolAnalyticsRequest| { &mut m.interval },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolAnalyticsRequest>(
            "PoolAnalyticsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolAnalyticsRequest {
    const NAME: &'static str = "PoolAnalyticsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.pool_id)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                34 => {
                    self.interval = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.pool_id.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.interval);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.pool_id.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(4, &self.interval)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolAnalyticsRequest {
        PoolAnalyticsRequest::new()
    }

    fn clear(&mut self) {
        self.pool_id.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolAnalyticsRequest {
        static instance: PoolAnalyticsRequest = PoolAnalyticsRequest {
            pool_id: ::protobuf::MessageField::none(),
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolAnalyticsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolAnalyticsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolAnalyticsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolAnalyticsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.PoolAnalyticsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PoolAnalyticsResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsResponse.volume_history)
    pub volume_history: ::protobuf::MessageField<VolumeHistory>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsResponse.tvl_history)
    pub tvl_history: ::std::vec::Vec<PricePoint>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsResponse.recent_transactions)
    pub recent_transactions: ::std::vec::Vec<PoolTransaction>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsResponse.top_positions)
    pub top_positions: ::std::vec::Vec<Position>,
    // @@protoc_insertion_point(field:oyl.PoolAnalyticsResponse.current_metrics)
    pub current_metrics: ::protobuf::MessageField<PoolMetrics>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.PoolAnalyticsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PoolAnalyticsResponse {
    fn default() -> &'a PoolAnalyticsResponse {
        <PoolAnalyticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl PoolAnalyticsResponse {
    pub fn new() -> PoolAnalyticsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VolumeHistory>(
            "volume_history",
            |m: &PoolAnalyticsResponse| { &m.volume_history },
            |m: &mut PoolAnalyticsResponse| { &mut m.volume_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tvl_history",
            |m: &PoolAnalyticsResponse| { &m.tvl_history },
            |m: &mut PoolAnalyticsResponse| { &mut m.tvl_history },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "recent_transactions",
            |m: &PoolAnalyticsResponse| { &m.recent_transactions },
            |m: &mut PoolAnalyticsResponse| { &mut m.recent_transactions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_positions",
            |m: &PoolAnalyticsResponse| { &m.top_positions },
            |m: &mut PoolAnalyticsResponse| { &mut m.top_positions },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, PoolMetrics>(
            "current_metrics",
            |m: &PoolAnalyticsResponse| { &m.current_metrics },
            |m: &mut PoolAnalyticsResponse| { &mut m.current_metrics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PoolAnalyticsResponse>(
            "PoolAnalyticsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PoolAnalyticsResponse {
    const NAME: &'static str = "PoolAnalyticsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.volume_history)?;
                },
                18 => {
                    self.tvl_history.push(is.read_message()?);
                },
                26 => {
                    self.recent_transactions.push(is.read_message()?);
                },
                34 => {
                    self.top_positions.push(is.read_message()?);
                },
                42 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.current_metrics)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.volume_history.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        for value in &self.tvl_history {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.recent_transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.top_positions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.current_metrics.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.volume_history.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        for v in &self.tvl_history {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.recent_transactions {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.top_positions {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if let Some(v) = self.current_metrics.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PoolAnalyticsResponse {
        PoolAnalyticsResponse::new()
    }

    fn clear(&mut self) {
        self.volume_history.clear();
        self.tvl_history.clear();
        self.recent_transactions.clear();
        self.top_positions.clear();
        self.current_metrics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PoolAnalyticsResponse {
        static instance: PoolAnalyticsResponse = PoolAnalyticsResponse {
            volume_history: ::protobuf::MessageField::none(),
            tvl_history: ::std::vec::Vec::new(),
            recent_transactions: ::std::vec::Vec::new(),
            top_positions: ::std::vec::Vec::new(),
            current_metrics: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PoolAnalyticsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PoolAnalyticsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PoolAnalyticsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PoolAnalyticsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.GlobalAnalyticsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlobalAnalyticsRequest {
    // message fields
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsRequest.start_time)
    pub start_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsRequest.end_time)
    pub end_time: ::protobuf::MessageField<Timestamp>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsRequest.interval)
    pub interval: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.GlobalAnalyticsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalAnalyticsRequest {
    fn default() -> &'a GlobalAnalyticsRequest {
        <GlobalAnalyticsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GlobalAnalyticsRequest {
    pub fn new() -> GlobalAnalyticsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "start_time",
            |m: &GlobalAnalyticsRequest| { &m.start_time },
            |m: &mut GlobalAnalyticsRequest| { &mut m.start_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Timestamp>(
            "end_time",
            |m: &GlobalAnalyticsRequest| { &m.end_time },
            |m: &mut GlobalAnalyticsRequest| { &mut m.end_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "interval",
            |m: &GlobalAnalyticsRequest| { &m.interval },
            |m: &mut GlobalAnalyticsRequest| { &mut m.interval },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalAnalyticsRequest>(
            "GlobalAnalyticsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalAnalyticsRequest {
    const NAME: &'static str = "GlobalAnalyticsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.start_time)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.end_time)?;
                },
                26 => {
                    self.interval = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.interval.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.interval);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.start_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.end_time.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if !self.interval.is_empty() {
            os.write_string(3, &self.interval)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalAnalyticsRequest {
        GlobalAnalyticsRequest::new()
    }

    fn clear(&mut self) {
        self.start_time.clear();
        self.end_time.clear();
        self.interval.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalAnalyticsRequest {
        static instance: GlobalAnalyticsRequest = GlobalAnalyticsRequest {
            start_time: ::protobuf::MessageField::none(),
            end_time: ::protobuf::MessageField::none(),
            interval: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalAnalyticsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalAnalyticsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalAnalyticsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalAnalyticsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.GlobalAnalyticsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GlobalAnalyticsResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.total_tvl)
    pub total_tvl: ::protobuf::MessageField<Price>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.total_volume_24h)
    pub total_volume_24h: ::protobuf::MessageField<Volume>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.total_pools)
    pub total_pools: u64,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.total_tokens)
    pub total_tokens: u64,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.total_users)
    pub total_users: u64,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.top_tokens_by_volume)
    pub top_tokens_by_volume: ::std::vec::Vec<TokenInfo>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.top_pools_by_tvl)
    pub top_pools_by_tvl: ::std::vec::Vec<PoolInfo>,
    // @@protoc_insertion_point(field:oyl.GlobalAnalyticsResponse.volume_history)
    pub volume_history: ::std::vec::Vec<VolumePoint>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.GlobalAnalyticsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GlobalAnalyticsResponse {
    fn default() -> &'a GlobalAnalyticsResponse {
        <GlobalAnalyticsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GlobalAnalyticsResponse {
    pub fn new() -> GlobalAnalyticsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Price>(
            "total_tvl",
            |m: &GlobalAnalyticsResponse| { &m.total_tvl },
            |m: &mut GlobalAnalyticsResponse| { &mut m.total_tvl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, Volume>(
            "total_volume_24h",
            |m: &GlobalAnalyticsResponse| { &m.total_volume_24h },
            |m: &mut GlobalAnalyticsResponse| { &mut m.total_volume_24h },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_pools",
            |m: &GlobalAnalyticsResponse| { &m.total_pools },
            |m: &mut GlobalAnalyticsResponse| { &mut m.total_pools },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_tokens",
            |m: &GlobalAnalyticsResponse| { &m.total_tokens },
            |m: &mut GlobalAnalyticsResponse| { &mut m.total_tokens },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_users",
            |m: &GlobalAnalyticsResponse| { &m.total_users },
            |m: &mut GlobalAnalyticsResponse| { &mut m.total_users },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_tokens_by_volume",
            |m: &GlobalAnalyticsResponse| { &m.top_tokens_by_volume },
            |m: &mut GlobalAnalyticsResponse| { &mut m.top_tokens_by_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "top_pools_by_tvl",
            |m: &GlobalAnalyticsResponse| { &m.top_pools_by_tvl },
            |m: &mut GlobalAnalyticsResponse| { &mut m.top_pools_by_tvl },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "volume_history",
            |m: &GlobalAnalyticsResponse| { &m.volume_history },
            |m: &mut GlobalAnalyticsResponse| { &mut m.volume_history },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GlobalAnalyticsResponse>(
            "GlobalAnalyticsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GlobalAnalyticsResponse {
    const NAME: &'static str = "GlobalAnalyticsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_tvl)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.total_volume_24h)?;
                },
                24 => {
                    self.total_pools = is.read_uint64()?;
                },
                32 => {
                    self.total_tokens = is.read_uint64()?;
                },
                40 => {
                    self.total_users = is.read_uint64()?;
                },
                50 => {
                    self.top_tokens_by_volume.push(is.read_message()?);
                },
                58 => {
                    self.top_pools_by_tvl.push(is.read_message()?);
                },
                66 => {
                    self.volume_history.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if let Some(v) = self.total_tvl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if let Some(v) = self.total_volume_24h.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if self.total_pools != 0 {
            my_size += ::protobuf::rt::uint64_size(3, self.total_pools);
        }
        if self.total_tokens != 0 {
            my_size += ::protobuf::rt::uint64_size(4, self.total_tokens);
        }
        if self.total_users != 0 {
            my_size += ::protobuf::rt::uint64_size(5, self.total_users);
        }
        for value in &self.top_tokens_by_volume {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.top_pools_by_tvl {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.volume_history {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if let Some(v) = self.total_tvl.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        }
        if let Some(v) = self.total_volume_24h.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        }
        if self.total_pools != 0 {
            os.write_uint64(3, self.total_pools)?;
        }
        if self.total_tokens != 0 {
            os.write_uint64(4, self.total_tokens)?;
        }
        if self.total_users != 0 {
            os.write_uint64(5, self.total_users)?;
        }
        for v in &self.top_tokens_by_volume {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        for v in &self.top_pools_by_tvl {
            ::protobuf::rt::write_message_field_with_cached_size(7, v, os)?;
        };
        for v in &self.volume_history {
            ::protobuf::rt::write_message_field_with_cached_size(8, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GlobalAnalyticsResponse {
        GlobalAnalyticsResponse::new()
    }

    fn clear(&mut self) {
        self.total_tvl.clear();
        self.total_volume_24h.clear();
        self.total_pools = 0;
        self.total_tokens = 0;
        self.total_users = 0;
        self.top_tokens_by_volume.clear();
        self.top_pools_by_tvl.clear();
        self.volume_history.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GlobalAnalyticsResponse {
        static instance: GlobalAnalyticsResponse = GlobalAnalyticsResponse {
            total_tvl: ::protobuf::MessageField::none(),
            total_volume_24h: ::protobuf::MessageField::none(),
            total_pools: 0,
            total_tokens: 0,
            total_users: 0,
            top_tokens_by_volume: ::std::vec::Vec::new(),
            top_pools_by_tvl: ::std::vec::Vec::new(),
            volume_history: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GlobalAnalyticsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GlobalAnalyticsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GlobalAnalyticsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalAnalyticsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.DisplayOptions)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisplayOptions {
    // message fields
    // @@protoc_insertion_point(field:oyl.DisplayOptions.unit)
    pub unit: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.DisplayOptions.locale)
    pub locale: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.DisplayOptions.decimal_places)
    pub decimal_places: u32,
    // @@protoc_insertion_point(field:oyl.DisplayOptions.use_scientific_notation)
    pub use_scientific_notation: bool,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.DisplayOptions.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisplayOptions {
    fn default() -> &'a DisplayOptions {
        <DisplayOptions as ::protobuf::Message>::default_instance()
    }
}

impl DisplayOptions {
    pub fn new() -> DisplayOptions {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit",
            |m: &DisplayOptions| { &m.unit },
            |m: &mut DisplayOptions| { &mut m.unit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "locale",
            |m: &DisplayOptions| { &m.locale },
            |m: &mut DisplayOptions| { &mut m.locale },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "decimal_places",
            |m: &DisplayOptions| { &m.decimal_places },
            |m: &mut DisplayOptions| { &mut m.decimal_places },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "use_scientific_notation",
            |m: &DisplayOptions| { &m.use_scientific_notation },
            |m: &mut DisplayOptions| { &mut m.use_scientific_notation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisplayOptions>(
            "DisplayOptions",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisplayOptions {
    const NAME: &'static str = "DisplayOptions";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.unit = is.read_string()?;
                },
                18 => {
                    self.locale = is.read_string()?;
                },
                24 => {
                    self.decimal_places = is.read_uint32()?;
                },
                32 => {
                    self.use_scientific_notation = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.unit.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.unit);
        }
        if !self.locale.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.locale);
        }
        if self.decimal_places != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.decimal_places);
        }
        if self.use_scientific_notation != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.unit.is_empty() {
            os.write_string(1, &self.unit)?;
        }
        if !self.locale.is_empty() {
            os.write_string(2, &self.locale)?;
        }
        if self.decimal_places != 0 {
            os.write_uint32(3, self.decimal_places)?;
        }
        if self.use_scientific_notation != false {
            os.write_bool(4, self.use_scientific_notation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisplayOptions {
        DisplayOptions::new()
    }

    fn clear(&mut self) {
        self.unit.clear();
        self.locale.clear();
        self.decimal_places = 0;
        self.use_scientific_notation = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisplayOptions {
        static instance: DisplayOptions = DisplayOptions {
            unit: ::std::string::String::new(),
            locale: ::std::string::String::new(),
            decimal_places: 0,
            use_scientific_notation: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisplayOptions {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisplayOptions").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisplayOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisplayOptions {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:oyl.ErrorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ErrorResponse {
    // message fields
    // @@protoc_insertion_point(field:oyl.ErrorResponse.error_code)
    pub error_code: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.ErrorResponse.error_message)
    pub error_message: ::std::string::String,
    // @@protoc_insertion_point(field:oyl.ErrorResponse.error_details)
    pub error_details: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:oyl.ErrorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ErrorResponse {
    fn default() -> &'a ErrorResponse {
        <ErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ErrorResponse {
    pub fn new() -> ErrorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_code",
            |m: &ErrorResponse| { &m.error_code },
            |m: &mut ErrorResponse| { &mut m.error_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_message",
            |m: &ErrorResponse| { &m.error_message },
            |m: &mut ErrorResponse| { &mut m.error_message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error_details",
            |m: &ErrorResponse| { &m.error_details },
            |m: &mut ErrorResponse| { &mut m.error_details },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ErrorResponse>(
            "ErrorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ErrorResponse {
    const NAME: &'static str = "ErrorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.error_code = is.read_string()?;
                },
                18 => {
                    self.error_message = is.read_string()?;
                },
                26 => {
                    self.error_details = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.error_code.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.error_code);
        }
        if !self.error_message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.error_message);
        }
        if !self.error_details.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.error_details);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.error_code.is_empty() {
            os.write_string(1, &self.error_code)?;
        }
        if !self.error_message.is_empty() {
            os.write_string(2, &self.error_message)?;
        }
        if !self.error_details.is_empty() {
            os.write_bytes(3, &self.error_details)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ErrorResponse {
        ErrorResponse::new()
    }

    fn clear(&mut self) {
        self.error_code.clear();
        self.error_message.clear();
        self.error_details.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ErrorResponse {
        static instance: ErrorResponse = ErrorResponse {
            error_code: ::std::string::String::new(),
            error_message: ::std::string::String::new(),
            error_details: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ErrorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ErrorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ErrorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:oyl.TransactionType)
pub enum TransactionType {
    // @@protoc_insertion_point(enum_value:oyl.TransactionType.TX_UNKNOWN)
    TX_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:oyl.TransactionType.TX_SWAP)
    TX_SWAP = 1,
    // @@protoc_insertion_point(enum_value:oyl.TransactionType.TX_ADD_LIQUIDITY)
    TX_ADD_LIQUIDITY = 2,
    // @@protoc_insertion_point(enum_value:oyl.TransactionType.TX_REMOVE_LIQUIDITY)
    TX_REMOVE_LIQUIDITY = 3,
    // @@protoc_insertion_point(enum_value:oyl.TransactionType.TX_COLLECT_FEES)
    TX_COLLECT_FEES = 4,
}

impl ::protobuf::Enum for TransactionType {
    const NAME: &'static str = "TransactionType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionType> {
        match value {
            0 => ::std::option::Option::Some(TransactionType::TX_UNKNOWN),
            1 => ::std::option::Option::Some(TransactionType::TX_SWAP),
            2 => ::std::option::Option::Some(TransactionType::TX_ADD_LIQUIDITY),
            3 => ::std::option::Option::Some(TransactionType::TX_REMOVE_LIQUIDITY),
            4 => ::std::option::Option::Some(TransactionType::TX_COLLECT_FEES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TransactionType> {
        match str {
            "TX_UNKNOWN" => ::std::option::Option::Some(TransactionType::TX_UNKNOWN),
            "TX_SWAP" => ::std::option::Option::Some(TransactionType::TX_SWAP),
            "TX_ADD_LIQUIDITY" => ::std::option::Option::Some(TransactionType::TX_ADD_LIQUIDITY),
            "TX_REMOVE_LIQUIDITY" => ::std::option::Option::Some(TransactionType::TX_REMOVE_LIQUIDITY),
            "TX_COLLECT_FEES" => ::std::option::Option::Some(TransactionType::TX_COLLECT_FEES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TransactionType] = &[
        TransactionType::TX_UNKNOWN,
        TransactionType::TX_SWAP,
        TransactionType::TX_ADD_LIQUIDITY,
        TransactionType::TX_REMOVE_LIQUIDITY,
        TransactionType::TX_COLLECT_FEES,
    ];
}

impl ::protobuf::EnumFull for TransactionType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TransactionType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TransactionType {
    fn default() -> Self {
        TransactionType::TX_UNKNOWN
    }
}

impl TransactionType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TransactionType>("TransactionType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:oyl.ActivityType)
pub enum ActivityType {
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_UNKNOWN)
    ACTIVITY_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_SEND)
    ACTIVITY_SEND = 1,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_RECEIVE)
    ACTIVITY_RECEIVE = 2,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_MINT)
    ACTIVITY_MINT = 3,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_BURN)
    ACTIVITY_BURN = 4,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_SWAP_IN)
    ACTIVITY_SWAP_IN = 5,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_SWAP_OUT)
    ACTIVITY_SWAP_OUT = 6,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_ADD_LIQUIDITY)
    ACTIVITY_ADD_LIQUIDITY = 7,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_REMOVE_LIQUIDITY)
    ACTIVITY_REMOVE_LIQUIDITY = 8,
    // @@protoc_insertion_point(enum_value:oyl.ActivityType.ACTIVITY_COLLECT_FEES)
    ACTIVITY_COLLECT_FEES = 9,
}

impl ::protobuf::Enum for ActivityType {
    const NAME: &'static str = "ActivityType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ActivityType> {
        match value {
            0 => ::std::option::Option::Some(ActivityType::ACTIVITY_UNKNOWN),
            1 => ::std::option::Option::Some(ActivityType::ACTIVITY_SEND),
            2 => ::std::option::Option::Some(ActivityType::ACTIVITY_RECEIVE),
            3 => ::std::option::Option::Some(ActivityType::ACTIVITY_MINT),
            4 => ::std::option::Option::Some(ActivityType::ACTIVITY_BURN),
            5 => ::std::option::Option::Some(ActivityType::ACTIVITY_SWAP_IN),
            6 => ::std::option::Option::Some(ActivityType::ACTIVITY_SWAP_OUT),
            7 => ::std::option::Option::Some(ActivityType::ACTIVITY_ADD_LIQUIDITY),
            8 => ::std::option::Option::Some(ActivityType::ACTIVITY_REMOVE_LIQUIDITY),
            9 => ::std::option::Option::Some(ActivityType::ACTIVITY_COLLECT_FEES),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ActivityType> {
        match str {
            "ACTIVITY_UNKNOWN" => ::std::option::Option::Some(ActivityType::ACTIVITY_UNKNOWN),
            "ACTIVITY_SEND" => ::std::option::Option::Some(ActivityType::ACTIVITY_SEND),
            "ACTIVITY_RECEIVE" => ::std::option::Option::Some(ActivityType::ACTIVITY_RECEIVE),
            "ACTIVITY_MINT" => ::std::option::Option::Some(ActivityType::ACTIVITY_MINT),
            "ACTIVITY_BURN" => ::std::option::Option::Some(ActivityType::ACTIVITY_BURN),
            "ACTIVITY_SWAP_IN" => ::std::option::Option::Some(ActivityType::ACTIVITY_SWAP_IN),
            "ACTIVITY_SWAP_OUT" => ::std::option::Option::Some(ActivityType::ACTIVITY_SWAP_OUT),
            "ACTIVITY_ADD_LIQUIDITY" => ::std::option::Option::Some(ActivityType::ACTIVITY_ADD_LIQUIDITY),
            "ACTIVITY_REMOVE_LIQUIDITY" => ::std::option::Option::Some(ActivityType::ACTIVITY_REMOVE_LIQUIDITY),
            "ACTIVITY_COLLECT_FEES" => ::std::option::Option::Some(ActivityType::ACTIVITY_COLLECT_FEES),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ActivityType] = &[
        ActivityType::ACTIVITY_UNKNOWN,
        ActivityType::ACTIVITY_SEND,
        ActivityType::ACTIVITY_RECEIVE,
        ActivityType::ACTIVITY_MINT,
        ActivityType::ACTIVITY_BURN,
        ActivityType::ACTIVITY_SWAP_IN,
        ActivityType::ACTIVITY_SWAP_OUT,
        ActivityType::ACTIVITY_ADD_LIQUIDITY,
        ActivityType::ACTIVITY_REMOVE_LIQUIDITY,
        ActivityType::ACTIVITY_COLLECT_FEES,
    ];
}

impl ::protobuf::EnumFull for ActivityType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ActivityType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ActivityType {
    fn default() -> Self {
        ActivityType::ACTIVITY_UNKNOWN
    }
}

impl ActivityType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ActivityType>("ActivityType")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\toyl.proto\x12\x03oyl\x1a\ralkanes.proto\"S\n\x07TokenId\x12&\n\x05bl\
    ock\x18\x01\x20\x01(\x0b2\x10.alkanes.uint128R\x05block\x12\x20\n\x02tx\
    \x18\x02\x20\x01(\x0b2\x10.alkanes.uint128R\x02tx\"R\n\x06PoolId\x12&\n\
    \x05block\x18\x01\x20\x01(\x0b2\x10.alkanes.uint128R\x05block\x12\x20\n\
    \x02tx\x18\x02\x20\x01(\x0b2\x10.alkanes.uint128R\x02tx\"%\n\tTimestamp\
    \x12\x18\n\x07seconds\x18\x01\x20\x01(\x04R\x07seconds\"9\n\x05Price\x12\
    \x14\n\x05value\x18\x01\x20\x01(\x01R\x05value\x12\x1a\n\x08currency\x18\
    \x02\x20\x01(\tR\x08currency\"[\n\x06Volume\x12(\n\x06amount\x18\x01\x20\
    \x01(\x0b2\x10.alkanes.uint128R\x06amount\x12'\n\tvalue_usd\x18\x02\x20\
    \x01(\x0b2\n.oyl.PriceR\x08valueUsd\"\"\n\nPercentage\x12\x14\n\x05value\
    \x18\x01\x20\x01(\x01R\x05value\"\xe5\x03\n\tTokenInfo\x12\x1c\n\x02id\
    \x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x02id\x12\x16\n\x06symbol\x18\
    \x02\x20\x01(\tR\x06symbol\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12\x19\n\x08logo_url\x18\x04\x20\x01(\tR\x07logoUrl\x12\x1b\n\tlogo_da\
    ta\x18\x05\x20\x01(\x0cR\x08logoData\x123\n\x0ctotal_supply\x18\x06\x20\
    \x01(\x0b2\x10.alkanes.uint128R\x0btotalSupply\x12?\n\x12circulating_sup\
    ply\x18\x07\x20\x01(\x0b2\x10.alkanes.uint128R\x11circulatingSupply\x12/\
    \n\nmax_supply\x18\x08\x20\x01(\x0b2\x10.alkanes.uint128R\tmaxSupply\x12\
    -\n\ncreated_at\x18\t\x20\x01(\x0b2\x0e.oyl.TimestampR\tcreatedAt\x12#\n\
    \rblock_created\x18\n\x20\x01(\rR\x0cblockCreated\x124\n\rmint_progress\
    \x18\x0b\x20\x01(\x0b2\x0f.oyl.PercentageR\x0cmintProgress\x12%\n\x0eexp\
    lorer_links\x18\x0c\x20\x03(\tR\rexplorerLinks\"\xbc\x03\n\nTokenPrice\
    \x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07tokenId\
    \x12/\n\rcurrent_price\x18\x02\x20\x01(\x0b2\n.oyl.PriceR\x0ccurrentPric\
    e\x127\n\x0fprice_change_1h\x18\x03\x20\x01(\x0b2\x0f.oyl.PercentageR\rp\
    riceChange1h\x129\n\x10price_change_24h\x18\x04\x20\x01(\x0b2\x0f.oyl.Pe\
    rcentageR\x0epriceChange24h\x127\n\x0fprice_change_7d\x18\x05\x20\x01(\
    \x0b2\x0f.oyl.PercentageR\rpriceChange7d\x129\n\x10price_change_30d\x18\
    \x06\x20\x01(\x0b2\x0f.oyl.PercentageR\x0epriceChange30d\x129\n\x10price\
    _change_all\x18\x07\x20\x01(\x0b2\x0f.oyl.PercentageR\x0epriceChangeAll\
    \x121\n\x0clast_updated\x18\x08\x20\x01(\x0b2\x0e.oyl.TimestampR\x0blast\
    Updated\"\xfc\x01\n\x0bTokenHolder\x12\x18\n\x07address\x18\x01\x20\x01(\
    \x0cR\x07address\x12*\n\x07balance\x18\x02\x20\x01(\x0b2\x10.alkanes.uin\
    t128R\x07balance\x12;\n\x11percent_of_supply\x18\x03\x20\x01(\x0b2\x0f.o\
    yl.PercentageR\x0fpercentOfSupply\x125\n\x0efirst_acquired\x18\x04\x20\
    \x01(\x0b2\x0e.oyl.TimestampR\rfirstAcquired\x123\n\rlast_activity\x18\
    \x05\x20\x01(\x0b2\x0e.oyl.TimestampR\x0clastActivity\"\xba\x03\n\x0cTok\
    enMetrics\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07t\
    okenId\x12#\n\rtotal_holders\x18\x02\x20\x01(\x04R\x0ctotalHolders\x12(\
    \n\tvolume_1h\x18\x03\x20\x01(\x0b2\x0b.oyl.VolumeR\x08volume1h\x12*\n\n\
    volume_24h\x18\x04\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolume24h\x12(\n\tvolu\
    me_7d\x18\x05\x20\x01(\x0b2\x0b.oyl.VolumeR\x08volume7d\x12*\n\nvolume_3\
    0d\x18\x06\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolume30d\x12*\n\nvolume_all\
    \x18\x07\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolumeAll\x12)\n\nmarket_cap\x18\
    \x08\x20\x01(\x0b2\n.oyl.PriceR\tmarketCap\x12\x1c\n\x03fdv\x18\t\x20\
    \x01(\x0b2\n.oyl.PriceR\x03fdv\x12\x1c\n\x03tvl\x18\n\x20\x01(\x0b2\n.oy\
    l.PriceR\x03tvl\x12\x1d\n\npool_count\x18\x0b\x20\x01(\rR\tpoolCount\"\
    \xc2\x03\n\x08PoolInfo\x12\x1b\n\x02id\x18\x01\x20\x01(\x0b2\x0b.oyl.Poo\
    lIdR\x02id\x12%\n\x07token_a\x18\x02\x20\x01(\x0b2\x0c.oyl.TokenIdR\x06t\
    okenA\x12%\n\x07token_b\x18\x03\x20\x01(\x0b2\x0c.oyl.TokenIdR\x06tokenB\
    \x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\x12-\n\treserve_a\x18\x05\
    \x20\x01(\x0b2\x10.alkanes.uint128R\x08reserveA\x12-\n\treserve_b\x18\
    \x06\x20\x01(\x0b2\x10.alkanes.uint128R\x08reserveB\x123\n\x0ctotal_supp\
    ly\x18\x07\x20\x01(\x0b2\x10.alkanes.uint128R\x0btotalSupply\x12-\n\ncre\
    ated_at\x18\x08\x20\x01(\x0b2\x0e.oyl.TimestampR\tcreatedAt\x12#\n\rbloc\
    k_created\x18\t\x20\x01(\rR\x0cblockCreated\x12#\n\rexplorer_link\x18\n\
    \x20\x01(\tR\x0cexplorerLink\x12+\n\nfactory_id\x18\x0b\x20\x01(\x0b2\
    \x0c.oyl.TokenIdR\tfactoryId\"\xa4\x06\n\x0bPoolMetrics\x12$\n\x07pool_i\
    d\x18\x01\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\x12\x1c\n\x03tvl\x18\
    \x02\x20\x01(\x0b2\n.oyl.PriceR\x03tvl\x123\n\rtvl_change_1h\x18\x03\x20\
    \x01(\x0b2\x0f.oyl.PercentageR\x0btvlChange1h\x125\n\x0etvl_change_24h\
    \x18\x04\x20\x01(\x0b2\x0f.oyl.PercentageR\x0ctvlChange24h\x123\n\rtvl_c\
    hange_7d\x18\x05\x20\x01(\x0b2\x0f.oyl.PercentageR\x0btvlChange7d\x125\n\
    \x0etvl_change_30d\x18\x06\x20\x01(\x0b2\x0f.oyl.PercentageR\x0ctvlChang\
    e30d\x12(\n\tvolume_1h\x18\x07\x20\x01(\x0b2\x0b.oyl.VolumeR\x08volume1h\
    \x12*\n\nvolume_24h\x18\x08\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolume24h\x12\
    (\n\tvolume_7d\x18\t\x20\x01(\x0b2\x0b.oyl.VolumeR\x08volume7d\x12*\n\nv\
    olume_30d\x18\n\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolume30d\x12*\n\nvolume_\
    all\x18\x0b\x20\x01(\x0b2\x0b.oyl.VolumeR\tvolumeAll\x12!\n\x03apr\x18\
    \x0c\x20\x01(\x0b2\x0f.oyl.PercentageR\x03apr\x120\n\x0efees_earned_1h\
    \x18\r\x20\x01(\x0b2\n.oyl.PriceR\x0cfeesEarned1h\x122\n\x0ffees_earned_\
    24h\x18\x0e\x20\x01(\x0b2\n.oyl.PriceR\rfeesEarned24h\x120\n\x0efees_ear\
    ned_7d\x18\x0f\x20\x01(\x0b2\n.oyl.PriceR\x0cfeesEarned7d\x122\n\x0ffees\
    _earned_30d\x18\x10\x20\x01(\x0b2\n.oyl.PriceR\rfeesEarned30d\x122\n\x0f\
    fees_earned_all\x18\x11\x20\x01(\x0b2\n.oyl.PriceR\rfeesEarnedAll\"\x9b\
    \x03\n\x0fPoolTransaction\x12\x17\n\x07tx_hash\x18\x01\x20\x01(\x0cR\x06\
    txHash\x12$\n\x07pool_id\x18\x02\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\
    \x12,\n\ttimestamp\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\ttimestamp\
    \x12!\n\x0cblock_height\x18\x04\x20\x01(\rR\x0bblockHeight\x12(\n\x04typ\
    e\x18\x05\x20\x01(\x0e2\x14.oyl.TransactionTypeR\x04type\x12!\n\x0cfrom_\
    address\x18\x06\x20\x01(\x0cR\x0bfromAddress\x12\x1d\n\nto_address\x18\
    \x07\x20\x01(\x0cR\ttoAddress\x125\n\rtoken_amounts\x18\x08\x20\x03(\x0b\
    2\x10.oyl.TokenAmountR\x0ctokenAmounts\x122\n\x0ftotal_value_usd\x18\t\
    \x20\x01(\x0b2\n.oyl.PriceR\rtotalValueUsd\x12!\n\x0cexplorer_url\x18\n\
    \x20\x01(\tR\x0bexplorerUrl\"\x89\x01\n\x0bTokenAmount\x12'\n\x08token_i\
    d\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07tokenId\x12(\n\x06amount\x18\
    \x02\x20\x01(\x0b2\x10.alkanes.uint128R\x06amount\x12'\n\tvalue_usd\x18\
    \x03\x20\x01(\x0b2\n.oyl.PriceR\x08valueUsd\"\x8b\x04\n\x08Position\x12$\
    \n\x07pool_id\x18\x01\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\x12%\n\x0e\
    wallet_address\x18\x02\x20\x01(\x0cR\rwalletAddress\x12:\n\x10lp_token_b\
    alance\x18\x03\x20\x01(\x0b2\x10.alkanes.uint128R\x0elpTokenBalance\x124\
    \n\rshare_percent\x18\x04\x20\x01(\x0b2\x0f.oyl.PercentageR\x0csharePerc\
    ent\x129\n\x0ftokens_supplied\x18\x05\x20\x03(\x0b2\x10.oyl.TokenAmountR\
    \x0etokensSupplied\x12<\n\x14fees_earned_realized\x18\x06\x20\x01(\x0b2\
    \n.oyl.PriceR\x12feesEarnedRealized\x12@\n\x16fees_earned_unrealized\x18\
    \x07\x20\x01(\x0b2\n.oyl.PriceR\x14feesEarnedUnrealized\x12-\n\ncreated_\
    at\x18\x08\x20\x01(\x0b2\x0e.oyl.TimestampR\tcreatedAt\x12#\n\rblock_cre\
    ated\x18\t\x20\x01(\rR\x0cblockCreated\x121\n\x0clast_updated\x18\n\x20\
    \x01(\x0b2\x0e.oyl.TimestampR\x0blastUpdated\"\xd0\x03\n\rActivityEvent\
    \x12\x17\n\x07tx_hash\x18\x01\x20\x01(\x0cR\x06txHash\x12,\n\ttimestamp\
    \x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\ttimestamp\x12!\n\x0cblock_hei\
    ght\x18\x03\x20\x01(\rR\x0bblockHeight\x12%\n\x04type\x18\x04\x20\x01(\
    \x0e2\x11.oyl.ActivityTypeR\x04type\x12!\n\x0cfrom_address\x18\x05\x20\
    \x01(\x0cR\x0bfromAddress\x12\x1d\n\nto_address\x18\x06\x20\x01(\x0cR\tt\
    oAddress\x12'\n\x08token_id\x18\x07\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07to\
    kenId\x12(\n\x06amount\x18\x08\x20\x01(\x0b2\x10.alkanes.uint128R\x06amo\
    unt\x12'\n\tvalue_usd\x18\t\x20\x01(\x0b2\n.oyl.PriceR\x08valueUsd\x12!\
    \n\x0cexplorer_url\x18\n\x20\x01(\tR\x0bexplorerUrl\x12$\n\x07pool_id\
    \x18\x0b\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\x12'\n\x0fadditional_da\
    ta\x18\x0c\x20\x01(\x0cR\x0eadditionalData\"\x97\x01\n\x0cActivityFeed\
    \x12*\n\x06events\x18\x01\x20\x03(\x0b2\x12.oyl.ActivityEventR\x06events\
    \x12\x1f\n\x0btotal_count\x18\x02\x20\x01(\x04R\ntotalCount\x12\x19\n\
    \x08has_more\x18\x03\x20\x01(\x08R\x07hasMore\x12\x1f\n\x0bnext_cursor\
    \x18\x04\x20\x01(\x0cR\nnextCursor\"\x81\x01\n\nPricePoint\x12,\n\ttimes\
    tamp\x18\x01\x20\x01(\x0b2\x0e.oyl.TimestampR\ttimestamp\x12\x20\n\x05pr\
    ice\x18\x02\x20\x01(\x0b2\n.oyl.PriceR\x05price\x12#\n\x06volume\x18\x03\
    \x20\x01(\x0b2\x0b.oyl.VolumeR\x06volume\"\xd6\x01\n\x0cPriceHistory\x12\
    '\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07tokenId\x12'\n\
    \x06points\x18\x02\x20\x03(\x0b2\x0f.oyl.PricePointR\x06points\x12-\n\ns\
    tart_time\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\tstartTime\x12)\n\x08\
    end_time\x18\x04\x20\x01(\x0b2\x0e.oyl.TimestampR\x07endTime\x12\x1a\n\
    \x08interval\x18\x05\x20\x01(\tR\x08interval\"\x8d\x01\n\x0bVolumePoint\
    \x12,\n\ttimestamp\x18\x01\x20\x01(\x0b2\x0e.oyl.TimestampR\ttimestamp\
    \x12#\n\x06volume\x18\x02\x20\x01(\x0b2\x0b.oyl.VolumeR\x06volume\x12+\n\
    \x11transaction_count\x18\x03\x20\x01(\rR\x10transactionCount\"\x8c\x02\
    \n\rVolumeHistory\x12)\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.Token\
    IdH\0R\x07tokenId\x12&\n\x07pool_id\x18\x02\x20\x01(\x0b2\x0b.oyl.PoolId\
    H\0R\x06poolId\x12(\n\x06points\x18\x03\x20\x03(\x0b2\x10.oyl.VolumePoin\
    tR\x06points\x12-\n\nstart_time\x18\x04\x20\x01(\x0b2\x0e.oyl.TimestampR\
    \tstartTime\x12)\n\x08end_time\x18\x05\x20\x01(\x0b2\x0e.oyl.TimestampR\
    \x07endTime\x12\x1a\n\x08interval\x18\x06\x20\x01(\tR\x08intervalB\x08\n\
    \x06target\"\x89\x01\n\x10TokenInfoRequest\x12'\n\x08token_id\x18\x01\
    \x20\x01(\x0b2\x0c.oyl.TokenIdR\x07tokenId\x12'\n\x0finclude_metrics\x18\
    \x02\x20\x01(\x08R\x0eincludeMetrics\x12#\n\rinclude_price\x18\x03\x20\
    \x01(\x08R\x0cincludePrice\"\x8d\x01\n\x11TokenInfoResponse\x12$\n\x05to\
    ken\x18\x01\x20\x01(\x0b2\x0e.oyl.TokenInfoR\x05token\x12+\n\x07metrics\
    \x18\x02\x20\x01(\x0b2\x11.oyl.TokenMetricsR\x07metrics\x12%\n\x05price\
    \x18\x03\x20\x01(\x0b2\x0f.oyl.TokenPriceR\x05price\"\xa0\x01\n\x15Token\
    sByHolderRequest\x12%\n\x0ewallet_address\x18\x01\x20\x01(\x0cR\rwalletA\
    ddress\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12\x16\n\x06curs\
    or\x18\x03\x20\x01(\x0cR\x06cursor\x122\n\x15include_zero_balances\x18\
    \x04\x20\x01(\x08R\x13includeZeroBalances\"\x82\x01\n\x16TokensByHolderR\
    esponse\x12,\n\x08holdings\x18\x01\x20\x03(\x0b2\x10.oyl.TokenHolderR\
    \x08holdings\x12\x19\n\x08has_more\x18\x02\x20\x01(\x08R\x07hasMore\x12\
    \x1f\n\x0bnext_cursor\x18\x03\x20\x01(\x0cR\nnextCursor\"\x9f\x01\n\x13T\
    okenHoldersRequest\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.Toke\
    nIdR\x07tokenId\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12\x16\
    \n\x06cursor\x18\x03\x20\x01(\x0cR\x06cursor\x121\n\x0bmin_balance\x18\
    \x04\x20\x01(\x0b2\x10.alkanes.uint128R\nminBalance\"\xa3\x01\n\x14Token\
    HoldersResponse\x12*\n\x07holders\x18\x01\x20\x03(\x0b2\x10.oyl.TokenHol\
    derR\x07holders\x12#\n\rtotal_holders\x18\x02\x20\x01(\x04R\x0ctotalHold\
    ers\x12\x19\n\x08has_more\x18\x03\x20\x01(\x08R\x07hasMore\x12\x1f\n\x0b\
    next_cursor\x18\x04\x20\x01(\x0cR\nnextCursor\"\xd5\x01\n\x18TokenPriceH\
    istoryRequest\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\
    \x07tokenId\x12-\n\nstart_time\x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\
    \tstartTime\x12)\n\x08end_time\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\
    \x07endTime\x12\x1a\n\x08interval\x18\x04\x20\x01(\tR\x08interval\x12\
    \x1a\n\x08currency\x18\x05\x20\x01(\tR\x08currency\"H\n\x19TokenPriceHis\
    toryResponse\x12+\n\x07history\x18\x01\x20\x01(\x0b2\x11.oyl.PriceHistor\
    yR\x07history\"`\n\x0fPoolInfoRequest\x12$\n\x07pool_id\x18\x01\x20\x01(\
    \x0b2\x0b.oyl.PoolIdR\x06poolId\x12'\n\x0finclude_metrics\x18\x02\x20\
    \x01(\x08R\x0eincludeMetrics\"a\n\x10PoolInfoResponse\x12!\n\x04pool\x18\
    \x01\x20\x01(\x0b2\r.oyl.PoolInfoR\x04pool\x12*\n\x07metrics\x18\x02\x20\
    \x01(\x0b2\x10.oyl.PoolMetricsR\x07metrics\"\x95\x01\n\x13PoolsByTokenRe\
    quest\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07token\
    Id\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12\x16\n\x06cursor\
    \x18\x03\x20\x01(\x0cR\x06cursor\x12'\n\x0finclude_metrics\x18\x04\x20\
    \x01(\x08R\x0eincludeMetrics\"\xa3\x01\n\x14PoolsByTokenResponse\x12#\n\
    \x05pools\x18\x01\x20\x03(\x0b2\r.oyl.PoolInfoR\x05pools\x12*\n\x07metri\
    cs\x18\x02\x20\x03(\x0b2\x10.oyl.PoolMetricsR\x07metrics\x12\x19\n\x08ha\
    s_more\x18\x03\x20\x01(\x08R\x07hasMore\x12\x1f\n\x0bnext_cursor\x18\x04\
    \x20\x01(\x0cR\nnextCursor\"\xf3\x01\n\x17PoolTransactionsRequest\x12$\n\
    \x07pool_id\x18\x01\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\x12-\n\nstar\
    t_time\x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\tstartTime\x12)\n\x08end\
    _time\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\x07endTime\x12*\n\x05type\
    s\x18\x04\x20\x03(\x0e2\x14.oyl.TransactionTypeR\x05types\x12\x14\n\x05l\
    imit\x18\x05\x20\x01(\rR\x05limit\x12\x16\n\x06cursor\x18\x06\x20\x01(\
    \x0cR\x06cursor\"\x90\x01\n\x18PoolTransactionsResponse\x128\n\x0ctransa\
    ctions\x18\x01\x20\x03(\x0b2\x14.oyl.PoolTransactionR\x0ctransactions\
    \x12\x19\n\x08has_more\x18\x02\x20\x01(\x08R\x07hasMore\x12\x1f\n\x0bnex\
    t_cursor\x18\x03\x20\x01(\x0cR\nnextCursor\"\xa1\x01\n\x0fAllPoolsReques\
    t\x12\x14\n\x05limit\x18\x01\x20\x01(\rR\x05limit\x12\x16\n\x06cursor\
    \x18\x02\x20\x01(\x0cR\x06cursor\x12'\n\x0finclude_metrics\x18\x03\x20\
    \x01(\x08R\x0eincludeMetrics\x12\x17\n\x07sort_by\x18\x04\x20\x01(\tR\
    \x06sortBy\x12\x1e\n\ndescending\x18\x05\x20\x01(\x08R\ndescending\"\xc0\
    \x01\n\x10AllPoolsResponse\x12#\n\x05pools\x18\x01\x20\x03(\x0b2\r.oyl.P\
    oolInfoR\x05pools\x12*\n\x07metrics\x18\x02\x20\x03(\x0b2\x10.oyl.PoolMe\
    tricsR\x07metrics\x12\x1f\n\x0btotal_pools\x18\x03\x20\x01(\x04R\ntotalP\
    ools\x12\x19\n\x08has_more\x18\x04\x20\x01(\x08R\x07hasMore\x12\x1f\n\
    \x0bnext_cursor\x18\x05\x20\x01(\x0cR\nnextCursor\"\xa6\x01\n\x19Positio\
    nsByAddressRequest\x12%\n\x0ewallet_address\x18\x01\x20\x01(\x0cR\rwalle\
    tAddress\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12\x16\n\x06cu\
    rsor\x18\x03\x20\x01(\x0cR\x06cursor\x124\n\x16include_zero_positions\
    \x18\x04\x20\x01(\x08R\x14includeZeroPositions\"\x85\x01\n\x1aPositionsB\
    yAddressResponse\x12+\n\tpositions\x18\x01\x20\x03(\x0b2\r.oyl.PositionR\
    \tpositions\x12\x19\n\x08has_more\x18\x02\x20\x01(\x08R\x07hasMore\x12\
    \x1f\n\x0bnext_cursor\x18\x03\x20\x01(\x0cR\nnextCursor\"\xa4\x01\n\x16P\
    ositionsByPoolRequest\x12$\n\x07pool_id\x18\x01\x20\x01(\x0b2\x0b.oyl.Po\
    olIdR\x06poolId\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\x05limit\x12\x16\
    \n\x06cursor\x18\x03\x20\x01(\x0cR\x06cursor\x126\n\x0emin_lp_balance\
    \x18\x04\x20\x01(\x0b2\x10.alkanes.uint128R\x0cminLpBalance\"\xab\x01\n\
    \x17PositionsByPoolResponse\x12+\n\tpositions\x18\x01\x20\x03(\x0b2\r.oy\
    l.PositionR\tpositions\x12'\n\x0ftotal_positions\x18\x02\x20\x01(\x04R\
    \x0etotalPositions\x12\x19\n\x08has_more\x18\x03\x20\x01(\x08R\x07hasMor\
    e\x12\x1f\n\x0bnext_cursor\x18\x04\x20\x01(\x0cR\nnextCursor\"\xf2\x01\n\
    \x16ActivityByTokenRequest\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.\
    oyl.TokenIdR\x07tokenId\x12-\n\nstart_time\x18\x02\x20\x01(\x0b2\x0e.oyl\
    .TimestampR\tstartTime\x12)\n\x08end_time\x18\x03\x20\x01(\x0b2\x0e.oyl.\
    TimestampR\x07endTime\x12'\n\x05types\x18\x04\x20\x03(\x0e2\x11.oyl.Acti\
    vityTypeR\x05types\x12\x14\n\x05limit\x18\x05\x20\x01(\rR\x05limit\x12\
    \x16\n\x06cursor\x18\x06\x20\x01(\x0cR\x06cursor\"@\n\x17ActivityByToken\
    Response\x12%\n\x04feed\x18\x01\x20\x01(\x0b2\x11.oyl.ActivityFeedR\x04f\
    eed\"\xa3\x02\n\x18ActivityByAddressRequest\x12%\n\x0ewallet_address\x18\
    \x01\x20\x01(\x0cR\rwalletAddress\x12-\n\nstart_time\x18\x02\x20\x01(\
    \x0b2\x0e.oyl.TimestampR\tstartTime\x12)\n\x08end_time\x18\x03\x20\x01(\
    \x0b2\x0e.oyl.TimestampR\x07endTime\x12'\n\x05types\x18\x04\x20\x03(\x0e\
    2\x11.oyl.ActivityTypeR\x05types\x12/\n\x0ctoken_filter\x18\x05\x20\x03(\
    \x0b2\x0c.oyl.TokenIdR\x0btokenFilter\x12\x14\n\x05limit\x18\x06\x20\x01\
    (\rR\x05limit\x12\x16\n\x06cursor\x18\x07\x20\x01(\x0cR\x06cursor\"B\n\
    \x19ActivityByAddressResponse\x12%\n\x04feed\x18\x01\x20\x01(\x0b2\x11.o\
    yl.ActivityFeedR\x04feed\"\xee\x01\n\x15ActivityByPoolRequest\x12$\n\x07\
    pool_id\x18\x01\x20\x01(\x0b2\x0b.oyl.PoolIdR\x06poolId\x12-\n\nstart_ti\
    me\x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\tstartTime\x12)\n\x08end_tim\
    e\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\x07endTime\x12'\n\x05types\
    \x18\x04\x20\x03(\x0e2\x11.oyl.ActivityTypeR\x05types\x12\x14\n\x05limit\
    \x18\x05\x20\x01(\rR\x05limit\x12\x16\n\x06cursor\x18\x06\x20\x01(\x0cR\
    \x06cursor\"?\n\x16ActivityByPoolResponse\x12%\n\x04feed\x18\x01\x20\x01\
    (\x0b2\x11.oyl.ActivityFeedR\x04feed\"\xb6\x01\n\x15TokenAnalyticsReques\
    t\x12'\n\x08token_id\x18\x01\x20\x01(\x0b2\x0c.oyl.TokenIdR\x07tokenId\
    \x12-\n\nstart_time\x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\tstartTime\
    \x12)\n\x08end_time\x18\x03\x20\x01(\x0b2\x0e.oyl.TimestampR\x07endTime\
    \x12\x1a\n\x08interval\x18\x04\x20\x01(\tR\x08interval\"\x9f\x02\n\x16To\
    kenAnalyticsResponse\x126\n\rprice_history\x18\x01\x20\x01(\x0b2\x11.oyl\
    .PriceHistoryR\x0cpriceHistory\x129\n\x0evolume_history\x18\x02\x20\x01(\
    \x0b2\x12.oyl.VolumeHistoryR\rvolumeHistory\x121\n\x0btop_holders\x18\
    \x03\x20\x03(\x0b2\x10.oyl.TokenHolderR\ntopHolders\x12#\n\x05pools\x18\
    \x04\x20\x03(\x0b2\r.oyl.PoolInfoR\x05pools\x12:\n\x0fcurrent_metrics\
    \x18\x05\x20\x01(\x0b2\x11.oyl.TokenMetricsR\x0ecurrentMetrics\"\xb2\x01\
    \n\x14PoolAnalyticsRequest\x12$\n\x07pool_id\x18\x01\x20\x01(\x0b2\x0b.o\
    yl.PoolIdR\x06poolId\x12-\n\nstart_time\x18\x02\x20\x01(\x0b2\x0e.oyl.Ti\
    mestampR\tstartTime\x12)\n\x08end_time\x18\x03\x20\x01(\x0b2\x0e.oyl.Tim\
    estampR\x07endTime\x12\x1a\n\x08interval\x18\x04\x20\x01(\tR\x08interval\
    \"\xba\x02\n\x15PoolAnalyticsResponse\x129\n\x0evolume_history\x18\x01\
    \x20\x01(\x0b2\x12.oyl.VolumeHistoryR\rvolumeHistory\x120\n\x0btvl_histo\
    ry\x18\x02\x20\x03(\x0b2\x0f.oyl.PricePointR\ntvlHistory\x12E\n\x13recen\
    t_transactions\x18\x03\x20\x03(\x0b2\x14.oyl.PoolTransactionR\x12recentT\
    ransactions\x122\n\rtop_positions\x18\x04\x20\x03(\x0b2\r.oyl.PositionR\
    \x0ctopPositions\x129\n\x0fcurrent_metrics\x18\x05\x20\x01(\x0b2\x10.oyl\
    .PoolMetricsR\x0ecurrentMetrics\"\x8e\x01\n\x16GlobalAnalyticsRequest\
    \x12-\n\nstart_time\x18\x01\x20\x01(\x0b2\x0e.oyl.TimestampR\tstartTime\
    \x12)\n\x08end_time\x18\x02\x20\x01(\x0b2\x0e.oyl.TimestampR\x07endTime\
    \x12\x1a\n\x08interval\x18\x03\x20\x01(\tR\x08interval\"\x90\x03\n\x17Gl\
    obalAnalyticsResponse\x12'\n\ttotal_tvl\x18\x01\x20\x01(\x0b2\n.oyl.Pric\
    eR\x08totalTvl\x125\n\x10total_volume_24h\x18\x02\x20\x01(\x0b2\x0b.oyl.\
    VolumeR\x0etotalVolume24h\x12\x1f\n\x0btotal_pools\x18\x03\x20\x01(\x04R\
    \ntotalPools\x12!\n\x0ctotal_tokens\x18\x04\x20\x01(\x04R\x0btotalTokens\
    \x12\x1f\n\x0btotal_users\x18\x05\x20\x01(\x04R\ntotalUsers\x12?\n\x14to\
    p_tokens_by_volume\x18\x06\x20\x03(\x0b2\x0e.oyl.TokenInfoR\x11topTokens\
    ByVolume\x126\n\x10top_pools_by_tvl\x18\x07\x20\x03(\x0b2\r.oyl.PoolInfo\
    R\rtopPoolsByTvl\x127\n\x0evolume_history\x18\x08\x20\x03(\x0b2\x10.oyl.\
    VolumePointR\rvolumeHistory\"\x9b\x01\n\x0eDisplayOptions\x12\x12\n\x04u\
    nit\x18\x01\x20\x01(\tR\x04unit\x12\x16\n\x06locale\x18\x02\x20\x01(\tR\
    \x06locale\x12%\n\x0edecimal_places\x18\x03\x20\x01(\rR\rdecimalPlaces\
    \x126\n\x17use_scientific_notation\x18\x04\x20\x01(\x08R\x15useScientifi\
    cNotation\"x\n\rErrorResponse\x12\x1d\n\nerror_code\x18\x01\x20\x01(\tR\
    \terrorCode\x12#\n\rerror_message\x18\x02\x20\x01(\tR\x0cerrorMessage\
    \x12#\n\rerror_details\x18\x03\x20\x01(\x0cR\x0cerrorDetails*r\n\x0fTran\
    sactionType\x12\x0e\n\nTX_UNKNOWN\x10\0\x12\x0b\n\x07TX_SWAP\x10\x01\x12\
    \x14\n\x10TX_ADD_LIQUIDITY\x10\x02\x12\x17\n\x13TX_REMOVE_LIQUIDITY\x10\
    \x03\x12\x13\n\x0fTX_COLLECT_FEES\x10\x04*\xf6\x01\n\x0cActivityType\x12\
    \x14\n\x10ACTIVITY_UNKNOWN\x10\0\x12\x11\n\rACTIVITY_SEND\x10\x01\x12\
    \x14\n\x10ACTIVITY_RECEIVE\x10\x02\x12\x11\n\rACTIVITY_MINT\x10\x03\x12\
    \x11\n\rACTIVITY_BURN\x10\x04\x12\x14\n\x10ACTIVITY_SWAP_IN\x10\x05\x12\
    \x15\n\x11ACTIVITY_SWAP_OUT\x10\x06\x12\x1a\n\x16ACTIVITY_ADD_LIQUIDITY\
    \x10\x07\x12\x1d\n\x19ACTIVITY_REMOVE_LIQUIDITY\x10\x08\x12\x19\n\x15ACT\
    IVITY_COLLECT_FEES\x10\tb\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::alkanes::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(55);
            messages.push(TokenId::generated_message_descriptor_data());
            messages.push(PoolId::generated_message_descriptor_data());
            messages.push(Timestamp::generated_message_descriptor_data());
            messages.push(Price::generated_message_descriptor_data());
            messages.push(Volume::generated_message_descriptor_data());
            messages.push(Percentage::generated_message_descriptor_data());
            messages.push(TokenInfo::generated_message_descriptor_data());
            messages.push(TokenPrice::generated_message_descriptor_data());
            messages.push(TokenHolder::generated_message_descriptor_data());
            messages.push(TokenMetrics::generated_message_descriptor_data());
            messages.push(PoolInfo::generated_message_descriptor_data());
            messages.push(PoolMetrics::generated_message_descriptor_data());
            messages.push(PoolTransaction::generated_message_descriptor_data());
            messages.push(TokenAmount::generated_message_descriptor_data());
            messages.push(Position::generated_message_descriptor_data());
            messages.push(ActivityEvent::generated_message_descriptor_data());
            messages.push(ActivityFeed::generated_message_descriptor_data());
            messages.push(PricePoint::generated_message_descriptor_data());
            messages.push(PriceHistory::generated_message_descriptor_data());
            messages.push(VolumePoint::generated_message_descriptor_data());
            messages.push(VolumeHistory::generated_message_descriptor_data());
            messages.push(TokenInfoRequest::generated_message_descriptor_data());
            messages.push(TokenInfoResponse::generated_message_descriptor_data());
            messages.push(TokensByHolderRequest::generated_message_descriptor_data());
            messages.push(TokensByHolderResponse::generated_message_descriptor_data());
            messages.push(TokenHoldersRequest::generated_message_descriptor_data());
            messages.push(TokenHoldersResponse::generated_message_descriptor_data());
            messages.push(TokenPriceHistoryRequest::generated_message_descriptor_data());
            messages.push(TokenPriceHistoryResponse::generated_message_descriptor_data());
            messages.push(PoolInfoRequest::generated_message_descriptor_data());
            messages.push(PoolInfoResponse::generated_message_descriptor_data());
            messages.push(PoolsByTokenRequest::generated_message_descriptor_data());
            messages.push(PoolsByTokenResponse::generated_message_descriptor_data());
            messages.push(PoolTransactionsRequest::generated_message_descriptor_data());
            messages.push(PoolTransactionsResponse::generated_message_descriptor_data());
            messages.push(AllPoolsRequest::generated_message_descriptor_data());
            messages.push(AllPoolsResponse::generated_message_descriptor_data());
            messages.push(PositionsByAddressRequest::generated_message_descriptor_data());
            messages.push(PositionsByAddressResponse::generated_message_descriptor_data());
            messages.push(PositionsByPoolRequest::generated_message_descriptor_data());
            messages.push(PositionsByPoolResponse::generated_message_descriptor_data());
            messages.push(ActivityByTokenRequest::generated_message_descriptor_data());
            messages.push(ActivityByTokenResponse::generated_message_descriptor_data());
            messages.push(ActivityByAddressRequest::generated_message_descriptor_data());
            messages.push(ActivityByAddressResponse::generated_message_descriptor_data());
            messages.push(ActivityByPoolRequest::generated_message_descriptor_data());
            messages.push(ActivityByPoolResponse::generated_message_descriptor_data());
            messages.push(TokenAnalyticsRequest::generated_message_descriptor_data());
            messages.push(TokenAnalyticsResponse::generated_message_descriptor_data());
            messages.push(PoolAnalyticsRequest::generated_message_descriptor_data());
            messages.push(PoolAnalyticsResponse::generated_message_descriptor_data());
            messages.push(GlobalAnalyticsRequest::generated_message_descriptor_data());
            messages.push(GlobalAnalyticsResponse::generated_message_descriptor_data());
            messages.push(DisplayOptions::generated_message_descriptor_data());
            messages.push(ErrorResponse::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(2);
            enums.push(TransactionType::generated_enum_descriptor_data());
            enums.push(ActivityType::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
