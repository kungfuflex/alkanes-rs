# Alkanes FFI Architecture

## Overview

The alkanes-rs project provides Foreign Function Interface (FFI) bindings to enable usage from multiple programming languages, with a primary focus on Kotlin/JVM for Android and server applications.

## Architecture Layers

```
┌────────────────────────────────────────────────────┐
│  Application Layer (Kotlin, Swift, Python, etc.)  │
│  - Android apps                                    │
│  - iOS apps                                        │
│  - JVM server applications                         │
│  - Python scripts                                  │
└────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────┐
│  Generated Bindings (Language-Specific)            │
│  - Type mappings                                   │
│  - Exception handling                              │
│  - Memory management                               │
│  Generated by UniFFI from .udl definition          │
└────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────┐
│  FFI Boundary (C-compatible interface)             │
│  - alkanes-ffi (cdylib)                           │
│  - alkanes-jni (cdylib for JVM)                   │
│  - Synchronous wrappers around async code          │
│  - Error conversion                                │
└────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────┐
│  Business Logic Layer                              │
│  - alkanes-cli-common                             │
│  - Platform-agnostic Rust code                     │
│  - Async operations with tokio runtime             │
└────────────────────────────────────────────────────┘
                         │
                         ▼
┌────────────────────────────────────────────────────┐
│  Core Libraries                                    │
│  - alkanes-support                                 │
│  - metashrew-support                               │
│  - protorune-support                               │
│  - Bitcoin/ordinals libraries                      │
└────────────────────────────────────────────────────┘
```

## Component Breakdown

### 1. alkanes-ffi

**Purpose**: Core FFI crate that provides C-compatible bindings using UniFFI.

**Key Features**:
- Defines public API in `alkanes.udl` (UniFFI Definition Language)
- Wraps `alkanes-cli-common` functionality
- Handles async-to-sync conversion (internal tokio runtime)
- Maps Rust `Result<T, E>` to exceptions in target languages
- Compiles to `cdylib` for dynamic linking

**Files**:
- `src/alkanes.udl` - API definition
- `src/lib.rs` - Implementation
- `build.rs` - UniFFI scaffolding generation
- `uniffi.toml` - Language-specific configuration

### 2. alkanes-jni

**Purpose**: Pre-configured crate specifically for JVM/Android integration.

**Key Features**:
- Thin wrapper around `alkanes-ffi`
- Additional JVM-specific build configuration
- Optimized for Android NDK cross-compilation
- Ready-to-use with `rust-android-gradle` plugin

**Files**:
- `src/lib.rs` - Re-exports from `alkanes-ffi`
- `build.rs` - JVM-specific build setup
- `examples/` - Android integration examples

### 3. Generated Bindings

UniFFI automatically generates language-specific bindings:

**Kotlin**:
- Package: `org.alkanes`
- Exception classes for each error variant
- Data classes for structs
- Sealed classes for enums
- Interface implementations as classes

**Swift**:
- Module: `Alkanes`
- Error enum with associated values
- Struct types
- Protocol implementations as classes

**Python**:
- Module: `alkanes`
- Exception classes
- Dataclass-like structs
- Enum types

## Type Mappings

### Primitive Types

| Rust | Kotlin | Swift | Python |
|------|--------|-------|--------|
| `u8` | `UByte` | `UInt8` | `int` |
| `u32` | `UInt` | `UInt32` | `int` |
| `u64` | `ULong` | `UInt64` | `int` |
| `u128` | `ULong` | `UInt64` | `int` |
| `i64` | `Long` | `Int64` | `int` |
| `f32` | `Float` | `Float` | `float` |
| `bool` | `Boolean` | `Bool` | `bool` |
| `String` | `String` | `String` | `str` |

### Complex Types

| Rust | Kotlin | Swift | Python |
|------|--------|-------|--------|
| `Vec<T>` | `List<T>` | `[T]` | `list[T]` |
| `Option<T>` | `T?` | `T?` | `Optional[T]` |
| `Result<T, E>` | throws | throws | raises |
| `struct` | `data class` | `struct` | `@dataclass` |
| `enum` | `sealed class` | `enum` | `Enum` |
| `Arc<Interface>` | `Interface` | `Interface` | `Interface` |

### Error Handling

Rust's `Result<T, E>` is mapped to exceptions:

**Rust**:
```rust
pub fn validate_address(address: String, network: Network) -> Result<bool> {
    // ...
}
```

**Kotlin**:
```kotlin
try {
    val isValid = validateAddress(address, Network.BITCOIN)
} catch (e: AlkanesException.InvalidAddress) {
    // Handle error
}
```

**Swift**:
```swift
do {
    let isValid = try validateAddress(address: address, network: .bitcoin)
} catch AlkanesError.InvalidAddress(let message) {
    // Handle error
}
```

## Async Operations

Rust async functions are wrapped with a tokio runtime:

**Rust Implementation**:
```rust
pub struct Wallet {
    runtime: tokio::runtime::Runtime,
    // ...
}

impl Wallet {
    pub fn sync(&self) -> Result<()> {
        // Blocking on async operation
        self.runtime.block_on(async {
            // Actual async implementation
        })
    }
}
```

**Foreign Language Usage** (synchronous):
```kotlin
// Appears synchronous to Kotlin code
wallet.sync()  // Internally blocks on async Rust operation
```

## Memory Management

UniFFI handles memory management across the FFI boundary:

1. **Rust → Foreign**: Rust objects are wrapped in `Arc<T>` and passed as opaque pointers
2. **Foreign → Rust**: Foreign objects are managed by their runtime, with lifetime tied to Rust `Arc`
3. **Cleanup**: When foreign object is garbage collected, Rust `Arc` is dropped

## Build Process

### For Native Development

```bash
# Build the library
cargo build --package alkanes-ffi --release

# Generate bindings
cd crates/alkanes-ffi
./examples/generate_bindings.sh
```

### For Android

```bash
# Install Android targets
rustup target add aarch64-linux-android
rustup target add x86_64-linux-android

# Use cargo-ndk
cargo install cargo-ndk
cargo ndk -t arm64-v8a build --release --package alkanes-jni
cargo ndk -t x86_64 build --release --package alkanes-jni
```

### With Android Gradle Plugin

The `rust-android-gradle` plugin automates this:

```kotlin
cargo {
    module = "path/to/alkanes-jni"
    libname = "alkanes_jni"
    targets = listOf("arm64", "x86_64")
}
```

## Design Patterns

### 1. Facade Pattern

The FFI layer provides a simplified facade over the complex `alkanes-cli-common` API:

```rust
// Simplified FFI function
pub fn generate_mnemonic(word_count: WordCount) -> Result<String>

// Wraps complex internal logic
// - BIP39 generation
// - Entropy management
// - Language selection
// - Error handling
```

### 2. Adapter Pattern

Each interface adapts alkanes-cli-common types to FFI-safe types:

```rust
// Internal type
use alkanes_cli_common::traits::WalletBalance as InnerWalletBalance;

// FFI-safe type
pub struct WalletBalance {
    pub confirmed: u64,
    pub pending: i64,
}

// Adapter
impl From<InnerWalletBalance> for WalletBalance {
    fn from(balance: InnerWalletBalance) -> Self {
        Self {
            confirmed: balance.confirmed,
            pending: balance.pending,
        }
    }
}
```

### 3. Runtime Encapsulation

Each interface object encapsulates a tokio runtime:

```rust
pub struct RpcClient {
    runtime: tokio::runtime::Runtime,
    // ...
}
```

This allows async Rust code to appear synchronous across FFI.

## Security Considerations

1. **Input Validation**: All inputs from foreign code are validated
2. **Error Handling**: No panics across FFI boundary (all handled with `Result`)
3. **Memory Safety**: `Arc<T>` ensures no use-after-free
4. **Sensitive Data**: Passphrases and mnemonics handled carefully (not logged)

## Testing Strategy

1. **Rust Unit Tests**: Test FFI functions in Rust
2. **UniFFI Binding Tests**: Test generated bindings
3. **Integration Tests**: Test from target language (Kotlin, Swift, Python)
4. **Android Instrumented Tests**: Test in actual Android environment

## Performance Considerations

1. **FFI Overhead**: Minimal (single function call overhead)
2. **Async Blocking**: Runtime blocks on async operations (acceptable for mobile)
3. **Memory Copies**: Minimize by using references where possible
4. **Parallelism**: Each interface has its own runtime for parallel operations

## Future Enhancements

1. **Streaming APIs**: Support for async streams across FFI
2. **Callback Support**: Allow foreign code to register callbacks
3. **More Languages**: Add bindings for Ruby, Go, etc.
4. **WebAssembly**: Support for WASM targets
5. **Direct Memory Access**: Zero-copy operations for large data

## Resources

- [UniFFI Documentation](https://mozilla.github.io/uniffi-rs/)
- [BDK-FFI](https://github.com/bitcoindevkit/bdk-ffi) - Reference implementation
- [rust-android-gradle](https://github.com/mozilla/rust-android-gradle)
- [Android NDK Guide](https://developer.android.com/ndk/guides)
